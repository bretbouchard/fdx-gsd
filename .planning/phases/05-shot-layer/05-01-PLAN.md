---
phase: 05-shot-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - core/shots/__init__.py
  - core/shots/types.py
  - core/shots/models.py
autonomous: true

must_haves:
  truths:
    - "Shot types are defined and accessible"
    - "Shot model has all required fields including evidence_ids"
    - "ShotList can serialize to JSON deterministically"
  artifacts:
    - path: "core/shots/types.py"
      provides: "ShotType, CameraAngle, CameraMovement enums"
      exports: ["ShotType", "CameraAngle", "CameraMovement"]
    - path: "core/shots/models.py"
      provides: "Shot, ShotList dataclasses"
      contains: "class Shot"
    - path: "core/shots/__init__.py"
      provides: "Module exports"
  key_links:
    - from: "core/shots/models.py"
      to: "core/shots/types.py"
      via: "import ShotType, CameraAngle, CameraMovement"
      pattern: "from .types import"
---

<objective>
Create the foundational types and data models for the Shot Layer.

Purpose: Establish the data structures for shot suggestions, following the Issue/BaseValidator pattern from Phase 4.
Output: core/shots/ module with types.py and models.py
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Pattern references from existing codebase
@core/validation/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create core/shots/types.py with enums</name>
  <files>core/shots/types.py</files>
  <action>
Create the shot type enums following the IssueSeverity pattern from core/validation/base.py.

Implement these enums:
1. ShotType (Enum):
   - WS = "WS" (Wide Shot)
   - MS = "MS" (Medium Shot)
   - MCU = "MCU" (Medium Close-Up)
   - CU = "CU" (Close-Up)
   - ECU = "ECU" (Extreme Close-Up)
   - INSERT = "INSERT" (Insert/Detail shot)
   - OTS = "OTS" (Over-the-shoulder)
   - POV = "POV" (Point of view)
   - TWO = "TWO" (Two-shot)

2. CameraAngle (Enum):
   - EYE_LEVEL = "eye-level"
   - HIGH = "high"
   - LOW = "low"
   - DUTCH = "dutch" (Tilted)

3. CameraMovement (Enum):
   - STATIC = "Static"
   - PAN = "Pan"
   - TILT = "Tilt"
   - DOLLY = "Dolly"
   - TRACKING = "Tracking"
   - HANDHELD = "Handheld"

Each enum should have a .value property that returns the string representation.
Include docstrings explaining each value.
  </action>
  <verify>python -c "from core.shots.types import ShotType, CameraAngle, CameraMovement; print(ShotType.CU.value)"</verify>
  <done>Enums importable and return correct string values</done>
</task>

<task type="auto">
  <name>Task 2: Create core/shots/models.py with Shot and ShotList dataclasses</name>
  <files>core/shots/models.py</files>
  <action>
Create the Shot and ShotList dataclasses following the Issue dataclass pattern from core/validation/base.py.

Shot dataclass fields:
- shot_id: str (unique identifier like "shot_000001")
- scene_id: str (scene this shot belongs to)
- scene_number: int (scene sequence number)
- shot_number: int (shot order within scene)
- shot_type: ShotType
- angle: CameraAngle = CameraAngle.EYE_LEVEL
- movement: CameraMovement = CameraMovement.STATIC
- description: str = ""
- subject: Optional[str] = None (character or object in focus)
- characters: List[str] = field(default_factory=list)
- location: str = ""
- evidence_ids: List[str] = field(default_factory=list)
- notes: Optional[str] = None
- suggested_at: datetime = field(default_factory=datetime.now)

Shot methods:
- to_dict() -> Dict[str, Any]: Convert to dictionary with .value for enums, sorted lists, isoformat datetime
- from_dict(cls, data) -> "Shot": Class method to reconstruct from dict

ShotList dataclass fields:
- project_id: str
- shots: List[Shot] = field(default_factory=list)
- generated_at: datetime = field(default_factory=datetime.now)

ShotList methods:
- to_dict() -> Dict[str, Any]: Full serialization with sorted shots by scene_number, shot_number
- save(path: Path): Write to JSON file with indent=2
- get_shots_for_scene(scene_id: str) -> List[Shot]: Filter shots by scene

Include proper type hints and docstrings. Sort evidence_ids and characters lists for deterministic output.
  </action>
  <verify>python -c "from core.shots.models import Shot, ShotList; from core.shots.types import ShotType; s = Shot(shot_id='test', scene_id='SCN_001', scene_number=1, shot_number=1, shot_type=ShotType.CU); print(s.to_dict())"</verify>
  <done>Shot and ShotList create, serialize, and deserialize correctly</done>
</task>

<task type="auto">
  <name>Task 3: Create core/shots/__init__.py with module exports</name>
  <files>core/shots/__init__.py</files>
  <action>
Create the module __init__.py to expose the main classes.

Export:
- from .types import ShotType, CameraAngle, CameraMovement
- from .models import Shot, ShotList

Include a module docstring describing the Shot Layer functionality.
  </action>
  <verify>python -c "from core.shots import Shot, ShotList, ShotType, CameraAngle, CameraMovement; print('OK')"</verify>
  <done>All types and models importable from core.shots</done>
</task>

</tasks>

<verification>
- All enums defined with correct values
- Shot dataclass matches Issue pattern structure
- ShotList serialization produces deterministic JSON (sorted lists)
- Module imports work correctly
</verification>

<success_criteria>
- `from core.shots import Shot, ShotList, ShotType, CameraAngle, CameraMovement` succeeds
- Shot.to_dict() produces JSON-serializable dict with sorted evidence_ids
- ShotList.save() writes valid JSON with shots sorted by scene_number, shot_number
</success_criteria>

<output>
After completion, create `.planning/phases/05-shot-layer/05-01-SUMMARY.md`
</output>
