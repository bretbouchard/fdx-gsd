---
phase: 02-script-composition
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - core/script/dialogue.py
  - core/script/builder.py
  - tests/unit/test_script_builder.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Dialogue is formatted with character names in ALL CAPS"
    - "Character names link to canonical entities from StoryGraph"
    - "Parentheticals are detected and formatted correctly"
    - "Dialogue paragraphs are ordered correctly within scenes"
  artifacts:
    - path: "core/script/dialogue.py"
      provides: "Dialogue detection and formatting with character resolution"
      exports: ["DialogueFormatter", "format_dialogue", "detect_speaker"]
    - path: "build/scriptgraph.json"
      provides: "ScriptGraph with properly typed dialogue paragraphs"
  key_links:
    - from: "core/script/dialogue.py"
      to: "build/storygraph.json"
      via: "character entity lookup"
      pattern: "entities.*type.*character"
    - from: "core/script/dialogue.py"
      to: "core/script/builder.py"
      via: "import DialogueFormatter"
      pattern: "from.*dialogue.*import"
---

<objective>
Implement dialogue formatting and character resolution for screenplay composition.

Purpose: Detect dialogue in narrative text, format it according to screenplay standards (character names centered, dialogue indented), and link speakers to canonical character entities from StoryGraph.

Output: DialogueFormatter module that integrates with ScriptBuilder to produce correctly typed dialogue paragraphs.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Built in Plan 01
@core/script/builder.py
@core/script/beats.py

# Reference patterns
@core/extraction/characters.py - Character name detection patterns
@core/scriptgraph/schema.json - Paragraph types
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dialogue formatter module</name>
  <files>core/script/dialogue.py</files>
  <action>
Create `core/script/dialogue.py` with dialogue detection and formatting.

The `DialogueFormatter` class should:
1. `__init__(self, character_entities: list[dict])` - Store known characters for matching
2. `detect_speaker(self, line: str, context: list[str]) -> Optional[dict]`
   - Check if line is a character name (ALL CAPS pattern)
   - Fuzzy match against known character names
   - Return matched character entity or None
3. `format_dialogue_block(self, speaker: dict, lines: list[str], evidence_ids: list[str]) -> list[dict]`
   - Return list of paragraphs: character name, optional parenthetical, dialogue
4. `extract_parenthetical(self, text: str) -> tuple[str, Optional[str]]`
   - Detect (parenthetical) at start of dialogue
   - Return (remaining_text, parenthetical) or (text, None)

Paragraph output format:
```python
# Character cue
{"type": "character", "text": "FOX", "evidence_ids": ["ev_x"], "meta": {"character_id": "CHAR_Fox_xxxx"}}

# Parenthetical (optional)
{"type": "parenthetical", "text": "(pauses)", "evidence_ids": ["ev_x"]}

# Dialogue
{"type": "dialogue", "text": "I knew this booth was bad luck.", "evidence_ids": ["ev_x"]}
```

Character matching:
- Exact match: "FOX" matches entity with name "Fox"
- Case-insensitive: "fox" matches "Fox"
- Alias match: "Johnny" matches entity with alias "Johnny"
- Confidence threshold: Below 0.7, queue for disambiguation (future)
  </action>
  <verify>
python -c "from core.script.dialogue import DialogueFormatter; f = DialogueFormatter([{'id': 'CHAR_Fox', 'name': 'Fox', 'aliases': []}]); print(f.detect_speaker('FOX', []))"
  </verify>
  <done>DialogueFormatter detects speakers and formats dialogue with character entity links</done>
</task>

<task type="auto">
  <name>Task 2: Integrate dialogue formatter into beat extraction</name>
  <files>core/script/beats.py</files>
  <action>
Update `core/script/beats.py` to use DialogueFormatter.

Changes to BeatExtractor:
1. Add `__init__(self, character_entities: list[dict] = None)` - Accept known characters
2. Add `dialogue_formatter: DialogueFormatter` property - Lazy initialization
3. Update `extract_beats()` to detect and format dialogue:
   - Scan for ALL CAPS lines that might be character names
   - If matched, use DialogueFormatter.format_dialogue_block()
   - Include character_id in paragraph meta

Dialogue detection heuristics:
1. Line is ALL CAPS (or mostly caps)
2. Line matches a known character name (fuzzy)
3. Next 1-3 lines are likely dialogue (not ALL CAPS, not empty)
4. Stop dialogue when: empty line, new scene heading, new character cue

Integration pattern:
```python
paragraphs = []
for line in lines:
    speaker = self.dialogue_formatter.detect_speaker(line, context)
    if speaker:
        dialogue_paras = self.dialogue_formatter.format_dialogue_block(...)
        paragraphs.extend(dialogue_paras)
    else:
        # Action beat
        paragraphs.append({"type": "action", "text": line, ...})
```
  </action>
  <verify>
python -c "from core.script.beats import BeatExtractor; e = BeatExtractor([{'id': 'CHAR_Fox', 'name': 'Fox'}]); print('Dialogue integration OK')"
  </verify>
  <done>BeatExtractor uses DialogueFormatter to produce typed dialogue paragraphs</done>
</task>

<task type="auto">
  <name>Task 3: Add dialogue tests to test suite</name>
  <files>tests/unit/test_script_builder.py</files>
  <action>
Add dialogue-specific tests to `tests/unit/test_script_builder.py`.

New test cases:
1. `test_speaker_detection_exact_match` - "FOX" matches "Fox" entity
2. `test_speaker_detection_case_insensitive` - "fox" matches "Fox"
3. `test_speaker_detection_alias` - "Johnny" matches entity with that alias
4. `test_speaker_no_match` - Unknown name returns None
5. `test_parenthetical_extraction` - "(pauses) Hello" splits correctly
6. `test_dialogue_block_formatting` - Produces character + dialogue paragraphs
7. `test_dialogue_character_id_in_meta` - Paragraph meta contains character_id
8. `test_full_scene_with_dialogue` - End-to-end: scene has both action and dialogue

Test fixture example:
```python
storygraph = {
    "entities": [
        {"id": "CHAR_Fox_1234", "type": "character", "name": "Fox", "aliases": []},
        {"id": "CHAR_Wolf_5678", "type": "character", "name": "Wolf", "aliases": ["The Wolf"]}
    ]
}
content = """
INT. DINER - NIGHT

FOX enters and sits down.

FOX
(pauses)
I knew this booth was bad luck.
"""
```
  </action>
  <verify>
python -m pytest tests/unit/test_script_builder.py -v -k "dialogue or speaker"
  </verify>
  <done>8 additional tests for dialogue formatting pass</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `python -m pytest tests/unit/test_script_builder.py -v` passes (18+ tests)
2. DialogueFormatter detects speakers from character entities
3. Dialogue paragraphs have correct types (character, parenthetical, dialogue)
4. Character IDs are included in paragraph metadata
</verification>

<success_criteria>
- [ ] core/script/dialogue.py exists with DialogueFormatter
- [ ] BeatExtractor integrates DialogueFormatter
- [ ] Speaker detection matches known characters
- [ ] Parentheticals are extracted separately
- [ ] 8 new dialogue tests pass
- [ ] Character IDs appear in paragraph meta
</success_criteria>

<output>
After completion, create `.planning/phases/02-script-composition/02-02-SUMMARY.md`
</output>
