---
phase: 02-script-composition
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - core/script/__init__.py
  - core/script/builder.py
  - core/script/beats.py
  - core/script/sluglines.py
  - core/scriptgraph/__init__.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "ScriptBuilder reads StoryGraph and produces ScriptGraph"
    - "Sluglines are generated from scene entities with canonical location names"
    - "Action beats are extracted from inbox content between scene boundaries"
    - "Every paragraph has evidence_ids linking to source"
  artifacts:
    - path: "core/script/builder.py"
      provides: "ScriptBuilder class that transforms StoryGraph to ScriptGraph"
      exports: ["ScriptBuilder", "ScriptBuildResult", "build_script"]
    - path: "core/script/beats.py"
      provides: "Beat extraction from narrative text"
      exports: ["BeatExtractor", "extract_beats"]
    - path: "core/script/sluglines.py"
      provides: "Slugline generation from scene metadata"
      exports: ["SluglineGenerator", "generate_slugline"]
    - path: "build/scriptgraph.json"
      provides: "ScriptGraph output file"
      contains: "scenes array with sluglines and paragraphs"
  key_links:
    - from: "core/script/builder.py"
      to: "build/storygraph.json"
      via: "json.load"
      pattern: "json\\.loads.*storygraph"
    - from: "core/script/builder.py"
      to: "build/scriptgraph.json"
      via: "json.dump"
      pattern: "json\\.dumps.*scriptgraph"
    - from: "core/script/sluglines.py"
      to: "core/extraction/scenes.py"
      via: "scene boundary patterns"
      pattern: "from.*extraction.*import"
---

<objective>
Create the ScriptBuilder class that transforms StoryGraph entities into ScriptGraph screenplay structure.

Purpose: Bridge the gap between extracted canon entities (Phase 1) and screenplay paragraphs. Read scene boundaries from StoryGraph, generate sluglines, extract action beats, and produce a valid ScriptGraph JSON.

Output: ScriptBuilder class with beat extraction and slugline generation that produces valid ScriptGraph JSON.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference implementations
@core/canon/__init__.py - CanonBuilder pattern to follow
@core/extraction/scenes.py - SceneBoundary detection
@core/scriptgraph/schema.json - Output schema

# FDX writer (already complete - will consume ScriptGraph)
@core/exporters/fdx_writer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create slugline generator module</name>
  <files>core/script/sluglines.py</files>
  <action>
Create `core/script/sluglines.py` with slugline generation logic.

The `SluglineGenerator` class should:
1. `generate_slugline(scene_entity: dict, storygraph: dict) -> str` - Generate "INT./EXT. LOCATION - TIME"
2. Resolve location name from storygraph entities (look up canonical name)
3. Normalize time_of_day: DAY, NIGHT, DAWN, DUSK, MORNING, AFTERNOON, EVENING, CONTINUOUS, LATER
4. Handle INT./EXT variants: INT, EXT, INT./EXT, EXT./INT

Format: `{INT_EXT}. {LOCATION} - {TIME}`

Examples:
- scene with int_ext="INT", location="Diner", time_of_day="NIGHT" -> "INT. DINER - NIGHT"
- scene with int_ext="EXT", location="City Street", time_of_day="DAY" -> "EXT. CITY STREET - DAY"

Location resolution:
- scene_entity.attributes["location"] contains the raw location string
- Look up in storygraph.entities for type="location" to get canonical name
- If not found, use raw location string as-is

Determinism: Always output uppercase, sorted consistently.
  </action>
  <verify>
python -c "from core.script.sluglines import SluglineGenerator; g = SluglineGenerator(); print(g.generate_slugline({'attributes': {'int_ext': 'INT', 'location': 'Diner', 'time_of_day': 'NIGHT'}}, {'entities': []}))"
  </verify>
  <done>SluglineGenerator class generates valid screenplay sluglines from scene entity metadata</done>
</task>

<task type="auto">
  <name>Task 2: Create beat extractor module</name>
  <files>core/script/beats.py</files>
  <action>
Create `core/script/beats.py` with beat extraction logic.

The `BeatExtractor` class should:
1. `extract_beats(content: str, scene_start_line: int, scene_end_line: int, block_refs: dict) -> list[dict]`
   - Extract action paragraphs between scene boundaries
   - Each beat becomes a paragraph with type="action"

2. `extract_dialogue(content: str, character_names: list[str], block_refs: dict) -> list[dict]`
   - Detect dialogue patterns (character name followed by speech)
   - Return paragraphs with type="character" and type="dialogue"

Paragraph structure (follows ScriptGraph schema):
```python
{
    "type": "action" | "character" | "dialogue" | "parenthetical",
    "text": "The actual paragraph text",
    "evidence_ids": ["ev_a1b2"],  # Block ref(s) for this content
    "meta": {}  # Optional metadata
}
```

Heuristics for beat detection:
- Action beats: Non-empty lines that are not scene headings, not dialogue
- Dialogue: Lines following ALL CAPS character name (within 1-2 lines)
- Character names: Lines that are ALL CAPS and match known character names

Evidence linking:
- Each paragraph must include evidence_ids from the source block refs
- Block refs map line ranges to evidence IDs from inbox files
  </action>
  <verify>
python -c "from core.script.beats import BeatExtractor; e = BeatExtractor(); beats = e.extract_beats('FOX enters. He looks around.', 0, 2, {0: 'ev_test'}); print(f'Beats: {len(beats)}')"
  </verify>
  <done>BeatExtractor extracts action beats and dialogue from text with evidence links</done>
</task>

<task type="auto">
  <name>Task 3: Create ScriptBuilder class</name>
  <files>core/script/builder.py, core/script/__init__.py</files>
  <action>
Create `core/script/builder.py` with ScriptBuilder class following CanonBuilder pattern.

The `ScriptBuilder` class should:
1. `__init__(self, project_path: Path, config: dict = None)` - Initialize paths and components
2. `build(self) -> ScriptBuildResult` - Execute full build pipeline
3. `_load_storygraph(self) -> dict` - Load storygraph.json
4. `_build_scene(self, scene_entity: dict, storygraph: dict) -> dict` - Build ScriptGraph scene
5. `_write_scriptgraph(self, scriptgraph: dict) -> None` - Write output file

`ScriptBuildResult` dataclass with:
- success: bool
- scenes_built: int
- paragraphs_created: int
- errors: list[str]

Build pipeline:
1. Load storygraph.json from build/
2. Filter entities for type="scene"
3. For each scene entity:
   a. Generate slugline using SluglineGenerator
   b. Extract paragraphs (beats + dialogue) from source content
   c. Build links (characters, locations, evidence_ids)
4. Write scriptgraph.json with deterministic sorting

Determinism requirements:
- Sort scenes by order field
- Sort entities by type then id
- Sort evidence_ids arrays
- JSON output with indent=2

Create `core/script/__init__.py`:
```python
from .builder import ScriptBuilder, ScriptBuildResult, build_script
from .sluglines import SluglineGenerator
from .beats import BeatExtractor
```
  </action>
  <verify>
python -c "from core.script import ScriptBuilder; print('ScriptBuilder imported OK')"
  </verify>
  <done>ScriptBuilder class exists and can be imported, follows CanonBuilder pattern</done>
</task>

<task type="auto">
  <name>Task 4: Add unit tests for script modules</name>
  <files>tests/unit/test_script_builder.py</files>
  <action>
Create `tests/unit/test_script_builder.py` with comprehensive tests.

Test cases:
1. `test_slugline_generation_basic` - INT. DINER - NIGHT format
2. `test_slugline_location_resolution` - Location looked up in storygraph entities
3. `test_slugline_missing_location` - Falls back to raw string
4. `test_beat_extraction_simple` - Single action beat extracted
5. `test_beat_extraction_multiple` - Multiple beats in sequence
6. `test_dialogue_detection` - Character name followed by speech detected
7. `test_evidence_linking` - Each paragraph has evidence_ids
8. `test_scriptbuilder_init` - ScriptBuilder initializes correctly
9. `test_scriptbuilder_produces_valid_scriptgraph` - Output validates against schema
10. `test_deterministic_output` - Same input produces identical JSON output

Use tmp_path fixture for file operations.
Create minimal storygraph fixtures for testing.
  </action>
  <verify>
python -m pytest tests/unit/test_script_builder.py -v --tb=short
  </verify>
  <done>All 10 tests pass, script builder tested in isolation</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `python -m pytest tests/unit/test_script_builder.py -v` passes
2. ScriptBuilder can be imported from core.script
3. SluglineGenerator produces valid screenplay sluglines
4. BeatExtractor extracts action beats with evidence links
5. Output ScriptGraph validates against schema
</verification>

<success_criteria>
- [ ] core/script/sluglines.py exists with SluglineGenerator
- [ ] core/script/beats.py exists with BeatExtractor
- [ ] core/script/builder.py exists with ScriptBuilder class
- [ ] core/script/__init__.py exports all components
- [ ] 10 unit tests pass in tests/unit/test_script_builder.py
- [ ] ScriptBuilder follows CanonBuilder pattern
- [ ] Output is deterministic (sorted JSON)
- [ ] All paragraphs have evidence_ids
</success_criteria>

<output>
After completion, create `.planning/phases/02-script-composition/02-01-SUMMARY.md`
</output>
