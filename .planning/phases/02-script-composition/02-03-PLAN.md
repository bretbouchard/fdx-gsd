---
phase: 02-script-composition
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/cli/cli.py
  - core/script/builder.py
  - core/scriptgraph/__init__.py
  - tests/integration/test_script_pipeline.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can run 'gsd build script' to generate ScriptGraph from StoryGraph"
    - "User can run 'gsd export fdx' to export screenplay to Final Draft format"
    - "ScriptGraph JSON validates against schema"
    - "FDX export opens in Final Draft (or compatible reader)"
  artifacts:
    - path: "apps/cli/cli.py"
      provides: "CLI command 'gsd build script'"
      contains: "def cmd_build"
    - path: "exports/script.fdx"
      provides: "Final Draft export file"
    - path: "build/scriptgraph.json"
      provides: "ScriptGraph JSON output"
  key_links:
    - from: "apps/cli/cli.py"
      to: "core/script/builder.py"
      via: "from core.script import build_script"
      pattern: "from.*script.*import"
    - from: "apps/cli/cli.py"
      to: "core/exporters/fdx_writer.py"
      via: "from core.exporters import write_fdx"
      pattern: "from.*exporters.*import"
---

<objective>
Complete CLI integration for 'gsd build script' command and end-to-end testing of the script composition pipeline.

Purpose: Enable users to run the full pipeline from canon to screenplay export. Connect ScriptBuilder to CLI, verify FDX export works end-to-end, and ensure the complete workflow is tested.

Output: Working 'gsd build script' command that produces valid FDX files from StoryGraph input.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Built in Plans 01-02
@core/script/builder.py
@core/script/dialogue.py

# Existing CLI (to extend)
@apps/cli/cli.py

# FDX export (already complete)
@core/exporters/fdx_writer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 'gsd build script' CLI command</name>
  <files>apps/cli/cli.py</files>
  <action>
Update `apps/cli/cli.py` to implement the 'gsd build script' command.

Currently at line ~370, the cmd_build function has a placeholder:
```python
elif what == "script":
    print("Building script... (Phase 2 - coming soon)")
    print("This will compose screenplay from storygraph.")
    return 0
```

Replace with full implementation:
1. Import build_script from core.script
2. Check that storygraph.json exists
3. Run build_script(project_path, config)
4. Report results (scenes built, paragraphs created)
5. Suggest next step: 'gsd export fdx'

Implementation pattern (follow cmd_build for canon):
```python
elif what == "script":
    from core.script import build_script

    print("Building script...")
    print(f"Project: {config['project']['name']}")
    print()

    # Check for storygraph
    storygraph_path = project_path / "build" / "storygraph.json"
    if not storygraph_path.exists():
        print("No storygraph.json found. Run 'gsd build canon' first.")
        return 1

    # Run script builder
    result = build_script(project_path, config)

    # Report results
    print()
    print("=== Script Build Results ===")
    print(f"Scenes: {result.scenes_built}")
    print(f"Paragraphs: {result.paragraphs_created}")

    if result.errors:
        print()
        print("Errors:")
        for error in result.errors:
            print(f"  - {error}")

    print()
    print(f"ScriptGraph: build/scriptgraph.json")
    print(f"Next: gsd export fdx")

    return 0 if result.success else 1
```
  </action>
  <verify>
cd /Users/bretbouchard/apps/fdx_gsd && python -c "from apps.cli.cli import cmd_build; print('cmd_build exists')"
  </verify>
  <done>'gsd build script' command is implemented and functional</done>
</task>

<task type="auto">
  <name>Task 2: Add ScriptGraph module exports</name>
  <files>core/scriptgraph/__init__.py</files>
  <action>
Update `core/scriptgraph/__init__.py` to export validation utilities.

Create or update with:
```python
"""ScriptGraph utilities."""

import json
from pathlib import Path
from typing import Dict, Any

# Schema location
SCHEMA_PATH = Path(__file__).parent / "schema.json"


def validate_scriptgraph(scriptgraph: Dict[str, Any]) -> bool:
    """
    Validate a ScriptGraph dict against the schema.

    Returns True if valid, raises ValidationError if invalid.
    """
    import jsonschema

    with open(SCHEMA_PATH) as f:
        schema = json.load(f)

    jsonschema.validate(scriptgraph, schema)
    return True


def load_scriptgraph(path: Path) -> Dict[str, Any]:
    """Load and validate a ScriptGraph JSON file."""
    data = json.loads(path.read_text())
    validate_scriptgraph(data)
    return data


def create_empty_scriptgraph(project_id: str) -> Dict[str, Any]:
    """Create an empty but valid ScriptGraph."""
    return {
        "version": "1.0",
        "project_id": project_id,
        "scenes": []
    }
```

Add jsonschema to requirements if not present (it should be from Phase 0).
  </action>
  <verify>
python -c "from core.scriptgraph import validate_scriptgraph, load_scriptgraph; print('ScriptGraph utils OK')"
  </verify>
  <done>ScriptGraph validation utilities are exported and importable</done>
</task>

<task type="auto">
  <name>Task 3: Create integration tests for full pipeline</name>
  <files>tests/integration/test_script_pipeline.py</files>
  <action>
Create `tests/integration/test_script_pipeline.py` for end-to-end testing.

Test cases:
1. `test_empty_storygraph_produces_empty_scriptgraph`
   - StoryGraph with no scenes produces empty ScriptGraph
2. `test_single_scene_pipeline`
   - StoryGraph with one scene produces ScriptGraph with slugline + beats
3. `test_multi_scene_ordering`
   - Multiple scenes appear in correct order in ScriptGraph
4. `test_dialogue_included_in_output`
   - Dialogue is properly typed in output paragraphs
5. `test_evidence_ids_preserved`
   - All paragraphs have evidence_ids from source
6. `test_scriptgraph_validates_against_schema`
   - Output validates with jsonschema
7. `test_fdx_export_from_scriptgraph`
   - FDXWriter produces valid XML from generated ScriptGraph
8. `test_deterministic_rebuild`
   - Running build twice produces identical output

Test fixture structure:
```python
@pytest.fixture
def sample_project(tmp_path):
    """Create a minimal project structure for testing."""
    # Create directories
    (tmp_path / "inbox").mkdir()
    (tmp_path / "build").mkdir()
    (tmp_path / "exports").mkdir()
    (tmp_path / "vault").mkdir()

    # Create storygraph
    storygraph = {
        "version": "1.0",
        "project_id": "test",
        "entities": [
            {"id": "SCN_001", "type": "scene", "name": "Diner", ...},
            {"id": "CHAR_Fox", "type": "character", "name": "Fox", ...}
        ]
    }
    (tmp_path / "build" / "storygraph.json").write_text(json.dumps(storygraph))

    return tmp_path
```
  </action>
  <verify>
python -m pytest tests/integration/test_script_pipeline.py -v --tb=short
  </verify>
  <done>All 8 integration tests pass, full pipeline tested end-to-end</done>
</task>

<task type="auto">
  <name>Task 4: Verify FDX export workflow</name>
  <files>tests/integration/test_script_pipeline.py</files>
  <action>
Add FDX-specific verification tests to integration test file.

Additional test cases:
9. `test_fdx_has_xml_declaration` - Output starts with <?xml
10. `test_fdx_has_final_draft_root` - Contains <FinalDraft> element
11. `test_fdx_scene_heading_type` - Sluglines are Type="Scene Heading"
12. `test_fdx_action_type` - Action beats are Type="Action"
13. `test_fdx_dialogue_types` - Character/Dialogue have correct types
14. `test_fdx_opens_in_final_draft`
    - This is a manual verification step documented in test
    - Include comment with instructions for manual FDX validation

Create a helper to run full workflow:
```python
def run_full_workflow(project_path):
    """Run: build canon -> build script -> export fdx"""
    from core.canon import build_canon
    from core.script import build_script
    from core.exporters import write_fdx

    # Step 1: Build canon (if needed)
    # Step 2: Build script
    script_result = build_script(project_path, {})

    # Step 3: Export FDX
    scriptgraph_path = project_path / "build" / "scriptgraph.json"
    fdx_path = project_path / "exports" / "script.fdx"
    write_fdx(scriptgraph_path, fdx_path)

    return fdx_path
```
  </action>
  <verify>
python -m pytest tests/integration/test_script_pipeline.py -v -k "fdx"
  </verify>
  <done>FDX export tests pass, workflow verified</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `python -m pytest tests/integration/test_script_pipeline.py -v` passes (14+ tests)
2. `gsd build script` command works in CLI
3. `gsd export fdx` produces valid FDX file
4. ScriptGraph validates against schema
5. FDX file opens in Final Draft (manual verification)
</verification>

<success_criteria>
- [ ] 'gsd build script' command is implemented
- [ ] ScriptGraph validation utilities exported
- [ ] 14 integration tests pass
- [ ] FDX export works end-to-end
- [ ] Full pipeline tested: canon -> script -> fdx
- [ ] Documentation includes manual FDX verification steps
</success_criteria>

<output>
After completion, create `.planning/phases/02-script-composition/02-03-SUMMARY.md`
</output>
