---
phase: 06-blender-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - core/layout/__init__.py
  - core/layout/models.py
  - core/layout/camera_math.py
autonomous: true

must_haves:
  truths:
    - "Layout brief models exist with all required fields (SceneLayout, CameraSetup, CharacterPosition)"
    - "Camera position calculation converts shot types to 3D coordinates"
    - "All models serialize to JSON deterministically"
  artifacts:
    - path: "core/layout/models.py"
      provides: "LayoutBrief, SceneLayout, CameraSetup, CharacterPosition, PropPosition dataclasses"
      exports: ["LayoutBrief", "SceneLayout", "CameraSetup", "CharacterPosition", "PropPosition"]
    - path: "core/layout/camera_math.py"
      provides: "Camera position calculation from shot types"
      exports: ["calculate_camera_position", "CameraPosition", "CameraRotation"]
  key_links:
    - from: "core/layout/models.py"
      to: "core/shots/models.py"
      via: "imports Shot, ShotList for source data"
      pattern: "from core.shots.models import"
    - from: "core/layout/camera_math.py"
      to: "core/layout/models.py"
      via: "CameraPosition used in CameraSetup"
---

<objective>
Create layout brief models and camera position calculation.

Purpose: Establish data structures for representing scene layouts, camera setups, and character positions that can be consumed by Blender_GSD or similar tools.
Output: core/layout/ module with models and camera math utilities.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-blender-integration/06-RESEARCH.md

# Reference existing patterns
@core/shots/models.py
@core/shots/types.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create core/layout module with data models</name>
  <files>
    core/layout/__init__.py
    core/layout/models.py
  </files>
  <action>
    Create the core/layout/ module with dataclass models following the Shot/ShotList pattern from core/shots/models.py.

    Create these dataclasses in models.py:

    1. Vector3 - 3D position/rotation with x, y, z floats
    2. CharacterPosition - character placement in scene:
       - character_id: str
       - name: str
       - position: Dict with x, y, z keys
       - facing: Dict with x, y, z keys (direction vector)
       - posture: str (default "standing")
       - blocking_notes: str
       - evidence_ids: List[str]
    3. PropPosition - prop/object placement:
       - prop_id: str
       - name: str
       - position: Dict with x, y, z keys
       - evidence_ids: List[str]
    4. CameraSetup - camera configuration for a shot:
       - setup_id: str (e.g., "CAM_shot_001")
       - shot_id: str (links to Shot.shot_id)
       - shot_type: str (WS, MS, CU, etc.)
       - camera: Dict with position, rotation, lens_mm, sensor_width
       - target: Dict with x, y, z (look-at point)
       - movement: str (Static, Pan, Tilt, etc.)
       - description: str
       - evidence_ids: List[str]
    5. SceneLayout - complete layout for one scene:
       - scene_id: str
       - slugline: str
       - location_id: str
       - int_ext: str ("INT" or "EXT")
       - time_of_day: str ("DAY", "NIGHT", etc.)
       - environment: Dict with description, lighting_preset
       - characters: List[CharacterPosition]
       - props: List[PropPosition]
       - camera_setups: List[CameraSetup]
       - evidence_ids: List[str]
    6. LayoutBrief - top-level container:
       - version: str ("1.0")
       - project_id: str
       - scene_layouts: List[SceneLayout]
       - generated_at: datetime

    Each dataclass must have:
    - to_dict() method returning JSON-serializable dict with sorted lists
    - from_dict() classmethod for deserialization
    - Lists sorted for deterministic output (sort by id fields)

    Create __init__.py with exports:
    ```python
    from .models import (
        LayoutBrief,
        SceneLayout,
        CameraSetup,
        CharacterPosition,
        PropPosition,
        Vector3,
    )
    ```
  </action>
  <verify>
    python -c "from core.layout import LayoutBrief, SceneLayout, CameraSetup, CharacterPosition, PropPosition; print('imports OK')"
  </verify>
  <done>
    - core/layout/__init__.py exists with all exports
    - core/layout/models.py exists with all 6 dataclasses
    - Each dataclass has to_dict() and from_dict() methods
    - Imports succeed without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create camera position calculation module</name>
  <files>core/layout/camera_math.py</files>
  <action>
    Create camera_math.py with cinematography-based camera position calculation.

    Based on RESEARCH.md Pattern 3, implement:

    1. CameraPosition dataclass - x, y, z floats for camera location
    2. CameraRotation dataclass - pitch, yaw, roll in degrees
    3. calculate_camera_position() function:
       ```python
       def calculate_camera_position(
           shot_type: str,
           subject_position: Tuple[float, float, float],
           subject_height: float = 1.7,
           lens_mm: float = 35.0,
           sensor_width: float = 36.0
       ) -> Tuple[CameraPosition, CameraRotation]
       ```
       - Maps shot types to standard distances:
         - WS: 5.0m (establishes location, full body + environment)
         - MS: 2.5m (waist up, standard dialogue)
         - MCU: 1.8m (chest up, intimate dialogue)
         - CU: 1.2m (face only, emotional moments)
         - ECU: 0.8m (single feature)
         - INSERT: 0.5m (props, objects)
         - OTS: 2.0m (over-the-shoulder)
         - POV: 1.7m (eye height)
         - TWO: 3.0m (two characters in frame)
       - Camera at eye level (1.6m) for most shots, raised (2.0m) for WS
       - Camera positioned in front of subject (negative Y in Blender's Z-up system)
       - Returns tuple of (CameraPosition, CameraRotation)

    4. point_camera_at_target() helper function:
       ```python
       def point_camera_at_target(
           camera_pos: CameraPosition,
           target: Tuple[float, float, float]
       ) -> CameraRotation
       ```
       - Calculates rotation to point camera at target
       - Uses direction vector math (no bpy dependency)
       - Returns CameraRotation with pitch, yaw, roll

    Document Blender coordinate system in module docstring:
    - X: right
    - Y: forward (into screen)
    - Z: up
    </action>
  <verify>
    python -c "
from core.layout.camera_math import calculate_camera_position, CameraPosition, CameraRotation
pos, rot = calculate_camera_position('WS', (0, 0, 0))
assert isinstance(pos, CameraPosition)
assert isinstance(rot, CameraRotation)
print('camera math OK')
"
  </verify>
  <done>
    - core/layout/camera_math.py exists
    - calculate_camera_position() works for all shot types
    - Returns valid CameraPosition and CameraRotation
    - Distance mapping correct per cinematography standards
  </done>
</task>

</tasks>

<verification>
1. All imports from core.layout succeed
2. Dataclasses serialize/deserialize correctly
3. Camera math produces valid coordinates for all shot types
4. Deterministic output (sorted lists in to_dict())
</verification>

<success_criteria>
- core/layout/models.py with 6 dataclasses (Vector3, CharacterPosition, PropPosition, CameraSetup, SceneLayout, LayoutBrief)
- core/layout/camera_math.py with calculate_camera_position() function
- All models have to_dict() and from_dict() methods
- Camera position calculation returns valid coordinates for WS, MS, MCU, CU, ECU, INSERT, OTS, POV, TWO shot types
</success_criteria>

<output>
After completion, create `.planning/phases/06-blender-integration/06-01-SUMMARY.md`
</output>
