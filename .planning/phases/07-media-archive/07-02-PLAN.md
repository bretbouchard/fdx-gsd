---
phase: 07-media-archive
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - core/archive/alias_manager.py
  - core/archive/index.py
autonomous: true

must_haves:
  truths:
    - "Alias search finds correct work from partial alias"
    - "aliases.json maps all aliases to canonical IDs"
    - "Fuzzy search works across work titles"
  artifacts:
    - path: "core/archive/alias_manager.py"
      provides: "Alias resolution and search"
      exports: ["AliasManager"]
    - path: "core/archive/index.py"
      provides: "Archive index management"
      exports: ["ArchiveIndex"]
  key_links:
    - from: "core/archive/alias_manager.py"
      to: "core/resolution/__init__.py"
      via: "FuzzyMatcher reuse"
      pattern: "from.*resolution.*import.*FuzzyMatcher"
---

<objective>
Create the alias management system that maps all aliases to canonical IDs and provides fuzzy search capabilities.

Purpose: Enable users to find works by any known name (title variations, working titles, abbreviations). Reuses FuzzyMatcher from canon extraction for consistency.
Output: AliasManager class for alias resolution and ArchiveIndex for searchable index.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Required - models from plan 01
@core/archive/models.py

# Pattern to follow - reuse FuzzyMatcher
@core/resolution/__init__.py

# Requirements reference
@.planning/REQUIREMENTS.md - ARC-04 (Alias Management)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AliasManager</name>
  <files>core/archive/alias_manager.py</files>
  <action>
Create `core/archive/alias_manager.py` with an AliasManager class that wraps FuzzyMatcher for archive-specific alias resolution.

The AliasManager should:

1. **Import and wrap FuzzyMatcher** from core.resolution
   - Do NOT reimplement fuzzy matching
   - Reuse the existing rapidfuzz-based implementation

2. **Class AliasManager** with methods:
   - `__init__(self, threshold: int = 70)` - initialize with fuzzy threshold
   - `register_alias(self, alias: str, canonical_id: str)` - add alias mapping
   - `register_work(self, work_id: str, title: str, aliases: list[str])` - register work with all aliases
   - `resolve(self, query: str) -> str | None` - find canonical ID from any alias (exact or fuzzy)
   - `search(self, query: str, limit: int = 5) -> list[tuple[str, str, float]]` - fuzzy search returning (canonical_id, matched_name, score)
   - `get_all_aliases(self, canonical_id: str) -> list[str]` - get all aliases for a work
   - `detect_conflict(self, alias: str) -> dict | None` - check if alias already maps to different work
   - `export_registry(self) -> dict` - export to AliasRegistry format
   - `import_registry(self, registry: dict)` - load from AliasRegistry format

3. **Conflict detection**:
   - When registering an alias that already exists, check if it maps to the same canonical_id
   - If different, return conflict info: {"alias": str, "existing_id": str, "new_id": str}

4. **Normalization**:
   - Lowercase and strip whitespace for matching
   - Preserve original case in stored aliases

Example usage:
```python
manager = AliasManager()
manager.register_work("work_abc123", "My Song", ["My Song", "my song (demo)", "MS"])
result = manager.resolve("my song demo")  # Returns "work_abc123"
```
</action>
  <verify>
python -c "
from core.archive.alias_manager import AliasManager
m = AliasManager()
m.register_work('work_001', 'Test Song', ['Test', 'TS'])
assert m.resolve('test') == 'work_001'
assert m.resolve('ts') == 'work_001'
print('OK')
"
</verify>
  <done>
AliasManager wraps FuzzyMatcher, supports register_work, resolve, search, and conflict detection.
</done>
</task>

<task type="auto">
  <name>Task 2: Create ArchiveIndex</name>
  <files>core/archive/index.py</files>
  <action>
Create `core/archive/index.py` with an ArchiveIndex class for maintaining a searchable index of all works.

The ArchiveIndex should:

1. **Class ArchiveIndex** with methods:
   - `__init__(self, archive_path: Path)` - initialize with archive directory path
   - `index_path` property - returns Path to index.json
   - `rebuild(self) -> dict` - scan all works and rebuild index
   - `load(self) -> dict` - load index from index.json
   - `save(self, index: dict)` - save index to index.json
   - `add_work(self, work: Work)` - add work to index
   - `remove_work(self, work_id: str)` - remove work from index
   - `search(self, query: str) -> list[dict]` - search works by title/alias
   - `get_work_summary(self, work_id: str) -> dict | None` - get summary of a work

2. **Index structure** (index.json):
```json
{
  "version": "1.0",
  "updated_at": "2026-02-19T...",
  "works": {
    "work_abc123": {
      "title": "My Song",
      "aliases": ["My Song", "MS", "my song (demo)"],
      "work_type": "song",
      "realization_count": 2,
      "performance_count": 5,
      "has_masters": true,
      "created_at": "2026-02-19T..."
    }
  },
  "by_type": {
    "song": ["work_abc123", ...],
    "composition": [...]
  }
}
```

3. **Integration with AliasManager**:
   - ArchiveIndex should use AliasManager for search
   - When rebuilding, populate AliasManager with all works

4. **Error handling**:
   - Handle missing index.json gracefully (create new)
   - Handle corrupted JSON (rebuild from scratch)
   - Log warnings for missing work directories
</action>
  <verify>
python -c "
from pathlib import Path
from core.archive.index import ArchiveIndex
from core.archive.models import Work, WorkMetadata
from datetime import datetime
idx = ArchiveIndex(Path('/tmp/test_archive'))
w = Work(id='work_001', work_type='song', metadata=WorkMetadata(title='Test', aliases=['Test'], created_at=datetime.now(), updated_at=datetime.now()))
idx.add_work(w)
assert 'work_001' in idx.load().get('works', {})
print('OK')
"
</verify>
  <done>
ArchiveIndex manages index.json with add_work, remove_work, search, and rebuild methods.
</done>
</task>

</tasks>

<verification>
- [ ] AliasManager imports FuzzyMatcher from core.resolution
- [ ] AliasManager.register_work adds work with all aliases
- [ ] AliasManager.resolve finds works by exact or fuzzy match
- [ ] ArchiveIndex creates and manages index.json
- [ ] ArchiveIndex integrates with AliasManager for search
</verification>

<success_criteria>
- AliasManager reuses FuzzyMatcher (not reimplemented)
- Fuzzy search finds works by partial aliases
- Index structure matches specification
- Both classes importable and functional
</success_criteria>

<output>
After completion, create `.planning/phases/07-media-archive/07-02-SUMMARY.md`
</output>
