---
phase: 07-media-archive
plan: 04
type: execute
wave: 3
depends_on: ["07-01", "07-02", "07-03"]
files_modified:
  - core/archive/registry.py
  - apps/cli/cli.py
autonomous: true

must_haves:
  truths:
    - "gsd archive register creates work entry with UUID"
    - "Multiple aliases supported on registration"
    - "Genre, year, ISRC metadata captured"
  artifacts:
    - path: "core/archive/registry.py"
      provides: "Work registration logic"
      exports: ["WorkRegistry"]
    - path: "apps/cli/cli.py"
      provides: "archive register command"
  key_links:
    - from: "apps/cli/cli.py"
      to: "core/archive/registry.py"
      via: "WorkRegistry.register_work"
      pattern: "WorkRegistry"
---

<objective>
Implement work registration with the `gsd archive register` command.

Purpose: Allow users to register creative works (songs, compositions) with full metadata and multiple aliases. Each work gets a canonical UUID for cross-referencing.
Output: WorkRegistry class and CLI command for registering works.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Required - models and alias manager from prior plans
@core/archive/models.py
@core/archive/alias_manager.py
@core/archive/index.py

# CLI pattern
@apps/cli/cli.py

# Requirements reference
@.planning/REQUIREMENTS.md - ARC-01 (Song/Work Registration), ARC-04 (Alias Management)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WorkRegistry</name>
  <files>core/archive/registry.py</files>
  <action>
Create `core/archive/registry.py` with a WorkRegistry class for managing work registration.

1. **Class WorkRegistry** with methods:
   - `__init__(self, archive_path: Path)` - initialize with archive directory
   - `register_work(self, title: str, work_type: str = "song", aliases: list[str] = None, genre: str = None, year: int = None, isrc: str = None, isbn: str = None, notes: str = None) -> Work` - register new work
   - `get_work(self, work_id: str) -> Work | None` - retrieve work by ID
   - `get_work_by_alias(self, alias: str) -> Work | None` - find work by any alias
   - `update_work(self, work_id: str, **updates) -> Work | None` - update work metadata
   - `add_alias(self, work_id: str, alias: str) -> bool` - add new alias to existing work
   - `list_works(self, work_type: str = None) -> list[Work]` - list all works, optionally filtered
   - `delete_work(self, work_id: str) -> bool` - delete work and its directory

2. **register_work implementation**:
   - Generate UUID: `work_{uuid4().hex[:8]}`
   - Create work directory: `archive/works/{work_id}/`
   - Create metadata.json in work directory
   - Create empty subdirectories: realizations/, performances/, assets/
   - Update aliases.json via AliasManager
   - Update index.json via ArchiveIndex
   - Return Work model

3. **Directory structure after registration**:
```
archive/
├── works/
│   └── work_abc12345/
│       ├── metadata.json
│       ├── realizations/
│       ├── performances/
│       └── assets/
├── aliases.json
└── index.json
```

4. **Error handling**:
   - Raise ValueError if title is empty
   - Return None if work_id not found
   - Log warning if alias already exists for different work

5. **Use imports**:
   - from core.archive.models import Work, WorkMetadata
   - from core.archive.alias_manager import AliasManager
   - from core.archive.index import ArchiveIndex
</action>
  <verify>
python -c "
from pathlib import Path
from core.archive.registry import WorkRegistry
from tempfile import TemporaryDirectory
with TemporaryDirectory() as tmp:
    reg = WorkRegistry(Path(tmp))
    w = reg.register_work('Test Song', aliases=['TS'])
    assert w.id.startswith('work_')
    assert w.metadata.title == 'Test Song'
    print('OK')
"
</verify>
  <done>
WorkRegistry can register, retrieve, update, and delete works with proper directory structure.
</done>
</task>

<task type="auto">
  <name>Task 2: Add Archive Register Command</name>
  <files>apps/cli/cli.py</files>
  <action>
Add the `gsd archive register` command to the CLI.

1. **Add cmd_archive_register function**:

```python
def cmd_archive_register(args: argparse.Namespace) -> int:
    """
    Register a new work in the archive.

    Usage: gsd archive register "Song Title" [options]
    """
    project_path, exit_code = find_project_root()
    if exit_code != 0:
        print("Error: Not in a GSD project.")
        return exit_code

    archive_path = project_path / "archive"
    if not archive_path.exists():
        print("Error: Archive not initialized. Run 'gsd archive init' first.")
        return 1

    from core.archive.registry import WorkRegistry

    registry = WorkRegistry(archive_path)

    # Parse aliases
    aliases = args.alias if args.alias else []

    # Register work
    try:
        work = registry.register_work(
            title=args.title,
            work_type=args.type or "song",
            aliases=aliases,
            genre=args.genre,
            year=args.year,
            isrc=args.isrc,
            isbn=args.isbn,
            notes=args.notes
        )

        print(f"OK Registered work: {work.metadata.title}")
        print(f"  ID: {work.id}")
        if aliases:
            print(f"  Aliases: {', '.join(aliases)}")
        if args.genre:
            print(f"  Genre: {args.genre}")
        if args.year:
            print(f"  Year: {args.year}")
        if args.isrc:
            print(f"  ISRC: {args.isrc}")
        print()
        print(f"Next: gsd archive realize {work.id} --name \"Version 1\"")

        return 0

    except ValueError as e:
        print(f"Error: {e}")
        return 1
```

2. **Add register subparser** to archive_sub:

```python
# archive register
p_register = archive_sub.add_parser("register", help="Register a new work")
p_register.add_argument("title", help="Work title")
p_register.add_argument("--alias", "-a", action="append", help="Add alias (can use multiple times)")
p_register.add_argument("--type", "-t", choices=["song", "composition", "script", "other"], default="song", help="Work type")
p_register.add_argument("--genre", "-g", help="Genre")
p_register.add_argument("--year", "-y", type=int, help="Year")
p_register.add_argument("--isrc", help="ISRC code (for songs)")
p_register.add_argument("--isbn", help="ISBN (for compositions)")
p_register.add_argument("--notes", "-n", help="Additional notes")
p_register.set_defaults(func=cmd_archive_register, archive_command="register")
```

3. **Update main()** to handle archive register in the existing archive command handler.
</action>
  <verify>
python -c "
import sys
sys.argv = ['gsd', 'archive', 'register', '--help']
# Should show help with --alias, --type, --genre options
" && echo "CLI parses archive register command"
</verify>
  <done>
`gsd archive register "Title" --alias "Alias1" --alias "Alias2"` creates work with metadata.
</done>
</task>

</tasks>

<verification>
- [ ] WorkRegistry.register_work creates work directory with metadata.json
- [ ] WorkRegistry creates realizations/, performances/, assets/ subdirectories
- [ ] CLI `gsd archive register` parses all options
- [ ] Aliases stored in aliases.json via AliasManager
- [ ] Work added to index.json via ArchiveIndex
</verification>

<success_criteria>
- Work registration creates complete directory structure
- Multiple aliases supported via --alias flag (repeatable)
- Genre, year, ISRC metadata captured
- Canonical UUID generated (work_{8chars})
</success_criteria>

<output>
After completion, create `.planning/phases/07-media-archive/07-04-SUMMARY.md`
</output>
