---
phase: 07-media-archive
plan: 05
type: execute
wave: 4
depends_on: ["07-04"]
files_modified:
  - core/archive/realization.py
  - apps/cli/cli.py
autonomous: true

must_haves:
  truths:
    - "gsd archive realize creates realization with session files"
    - "DAW session files (.als, .flp, .ptx) tracked"
    - "Stems and masters organized by realization"
  artifacts:
    - path: "core/archive/realization.py"
      provides: "Realization management"
      exports: ["RealizationManager"]
    - path: "apps/cli/cli.py"
      provides: "archive realize command"
  key_links:
    - from: "core/archive/realization.py"
      to: "archive/works/{work_id}/realizations/"
      via: "file operations"
      pattern: "realizations/"
---

<objective>
Implement realization tracking with the `gsd archive realize` command.

Purpose: Track studio versions, demos, and remixes of works. Organize DAW session files, stems, and master outputs by realization.
Output: RealizationManager class and CLI command for adding realizations.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Required - models and registry from prior plans
@core/archive/models.py
@core/archive/registry.py

# CLI pattern
@apps/cli/cli.py

# Requirements reference
@.planning/REQUIREMENTS.md - ARC-02 (Realization Tracking)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RealizationManager</name>
  <files>core/archive/realization.py</files>
  <action>
Create `core/archive/realization.py` with a RealizationManager class.

1. **Class RealizationManager** with methods:
   - `__init__(self, archive_path: Path)` - initialize with archive directory
   - `create_realization(self, work_id: str, name: str, date: date = None, studio: str = None, engineer: str = None, producer: str = None, version: str = None, notes: str = None) -> Realization` - create new realization
   - `get_realization(self, realization_id: str) -> Realization | None` - retrieve realization
   - `list_realizations(self, work_id: str) -> list[Realization]` - list all realizations for a work
   - `add_session_file(self, realization_id: str, file_path: Path) -> str` - copy/add DAW session file
   - `add_stem(self, realization_id: str, file_path: Path, stem_name: str = None) -> str` - copy/add stem file
   - `add_master(self, realization_id: str, file_path: Path) -> str` - copy/add master file
   - `delete_realization(self, realization_id: str) -> bool` - delete realization and files

2. **create_realization implementation**:
   - Verify work exists (raise ValueError if not)
   - Generate UUID: `real_{uuid4().hex[:8]}`
   - Create realization directory: `archive/works/{work_id}/realizations/{realization_id}/`
   - Create metadata.json in realization directory
   - Create subdirectories: sessions/, stems/, masters/
   - Update parent work's realizations list
   - Return Realization model

3. **File handling**:
   - add_session_file: Copy file to sessions/, validate extension (.als, .flp, .ptx, .logic)
   - add_stem: Copy file to stems/, optionally rename with stem_name
   - add_master: Copy file to masters/, validate audio extension
   - Return relative path within archive

4. **Directory structure after realization**:
```
archive/works/{work_id}/
├── metadata.json
├── realizations/
│   └── real_xyz789/
│       ├── metadata.json
│       ├── sessions/
│       │   └── song_v1.als
│       ├── stems/
│       │   ├── vocals.wav
│       │   └── drums.wav
│       └── masters/
│           └── final_mix.wav
├── performances/
└── assets/
```

5. **Use imports**:
   - from core.archive.models import Realization, RealizationMetadata
   - from core.archive.registry import WorkRegistry
   - import shutil for file copying
</action>
  <verify>
python -c "
from pathlib import Path
from core.archive.realization import RealizationManager
from core.archive.registry import WorkRegistry
from tempfile import TemporaryDirectory
with TemporaryDirectory() as tmp:
    reg = WorkRegistry(Path(tmp))
    w = reg.register_work('Test Song')
    rm = RealizationManager(Path(tmp))
    r = rm.create_realization(w.id, 'Studio Version')
    assert r.id.startswith('real_')
    assert r.metadata.name == 'Studio Version'
    print('OK')
"
</verify>
  <done>
RealizationManager creates realizations with sessions/, stems/, masters/ directories.
</done>
</task>

<task type="auto">
  <name>Task 2: Add Archive Realize Command</name>
  <files>apps/cli/cli.py</files>
  <action>
Add the `gsd archive realize` command to the CLI.

1. **Add cmd_archive_realize function**:

```python
def cmd_archive_realize(args: argparse.Namespace) -> int:
    """
    Add a realization to a work.

    Usage: gsd archive realize {work_id} --name "Version Name" [options]
    """
    project_path, exit_code = find_project_root()
    if exit_code != 0:
        print("Error: Not in a GSD project.")
        return exit_code

    archive_path = project_path / "archive"
    if not archive_path.exists():
        print("Error: Archive not initialized.")
        return 1

    from core.archive.realization import RealizationManager
    from core.archive.registry import WorkRegistry
    from datetime import datetime as dt

    # Resolve work_id (might be alias)
    registry = WorkRegistry(archive_path)
    work = registry.get_work_by_alias(args.work_id)
    if not work:
        work = registry.get_work(args.work_id)

    if not work:
        print(f"Error: Work not found: {args.work_id}")
        return 1

    # Parse date
    realization_date = None
    if args.date:
        try:
            realization_date = dt.strptime(args.date, "%Y-%m-%d").date()
        except ValueError:
            print(f"Error: Invalid date format. Use YYYY-MM-DD")
            return 1

    # Create realization
    manager = RealizationManager(archive_path)
    try:
        realization = manager.create_realization(
            work_id=work.id,
            name=args.name,
            date=realization_date,
            studio=args.studio,
            engineer=args.engineer,
            producer=args.producer,
            version=args.version,
            notes=args.notes
        )

        print(f"OK Created realization: {realization.metadata.name}")
        print(f"  Work: {work.metadata.title}")
        print(f"  ID: {realization.id}")
        if args.studio:
            print(f"  Studio: {args.studio}")
        if args.engineer:
            print(f"  Engineer: {args.engineer}")
        print()
        print(f"Add files:")
        print(f"  cp session.als {archive_path}/works/{work.id}/realizations/{realization.id}/sessions/")
        print(f"  cp stem.wav {archive_path}/works/{work.id}/realizations/{realization.id}/stems/")

        return 0

    except ValueError as e:
        print(f"Error: {e}")
        return 1
```

2. **Add realize subparser** to archive_sub:

```python
# archive realize
p_realize = archive_sub.add_parser("realize", help="Add a realization to a work")
p_realize.add_argument("work_id", help="Work ID or alias")
p_realize.add_argument("--name", "-n", required=True, help="Realization name (e.g., 'Studio Version')")
p_realize.add_argument("--date", "-d", help="Date (YYYY-MM-DD)")
p_realize.add_argument("--studio", "-s", help="Studio name")
p_realize.add_argument("--engineer", "-e", help="Engineer name")
p_realize.add_argument("--producer", "-p", help="Producer name")
p_realize.add_argument("--version", "-v", help="Version identifier")
p_realize.add_argument("--notes", help="Additional notes")
p_realize.set_defaults(func=cmd_archive_realize, archive_command="realize")
```
</action>
  <verify>
python -c "
import sys
sys.argv = ['gsd', 'archive', 'realize', '--help']
# Should show help with --name, --studio, --engineer options
" && echo "CLI parses archive realize command"
</verify>
  <done>
`gsd archive realize {work_id} --name "Studio Version"` creates realization with metadata.
</done>
</task>

</tasks>

<verification>
- [ ] RealizationManager.create_realization creates realization directory
- [ ] RealizationManager creates sessions/, stems/, masters/ subdirectories
- [ ] CLI `gsd archive realize` parses work_id (supports aliases)
- [ ] Realization metadata includes date, studio, engineer, producer
- [ ] Parent work's realizations list updated
</verification>

<success_criteria>
- Realizations organized by work
- DAW session directory structure created
- Engineer, studio, date metadata captured
- Works with alias resolution
</success_criteria>

<output>
After completion, create `.planning/phases/07-media-archive/07-05-SUMMARY.md`
</output>
