---
phase: 07-media-archive
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .gitattributes
  - core/archive/__init__.py
  - core/archive/models.py
autonomous: true

must_haves:
  truths:
    - "Git LFS handles all binary media files automatically"
    - "Archive models define work, realization, and performance structures"
  artifacts:
    - path: ".gitattributes"
      provides: "Git LFS configuration for binary files"
      contains: "filter=lfs"
    - path: "core/archive/models.py"
      provides: "Data models for archive entities"
      exports: ["Work", "Realization", "Performance", "WorkMetadata"]
  key_links:
    - from: ".gitattributes"
      to: "Git LFS"
      via: "Git attribute rules"
      pattern: "filter=lfs"
---

<objective>
Set up Git LFS for binary media files and create the archive data models.

Purpose: Foundation layer for the media archive system. Git LFS prevents repository bloat from large audio/video files, while models define the structure for works, realizations, and performances.
Output: Configured .gitattributes and core/archive/models.py with Pydantic models.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns to follow
@core/canon/__init__.py - CanonBuilder pattern
@core/resolution/__init__.py - FuzzyMatcher pattern (will reuse for aliases)

# Requirements reference
@.planning/REQUIREMENTS.md - ARC-05 (Git LFS), ARC-01/02/03 (models)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Git LFS for Media Files</name>
  <files>.gitattributes</files>
  <action>
Create or update `.gitattributes` in the project root to configure Git LFS for all binary media types.

Include these file extensions:
- Audio: .wav, .flac, .mp3, .aiff, .ogg, .m4a, .wma
- Video: .mp4, .mov, .avi, .mkv, .wmv, .webm
- Images: .png, .jpg, .jpeg, .gif, .bmp, .tiff, .psd, .ai, .svg, .raw, .cr2
- DAW: .als (Ableton), .flp (FL Studio), .ptx (Pro Tools), .logic (Logic Pro)
- Archives: .zip, .rar, .7z (for bundled sessions)

Format each line as:
```
*.ext filter=lfs diff=lfs merge=lfs -text
```

If .gitattributes already exists, append these rules. Do not remove existing rules.
</action>
  <verify>
cat .gitattributes | grep -c "filter=lfs" should return at least 20 (number of media types)
</verify>
  <done>
.gitattributes contains Git LFS rules for all audio, video, image, DAW, and archive file types.
</done>
</task>

<task type="auto">
  <name>Task 2: Create Archive Data Models</name>
  <files>core/archive/__init__.py, core/archive/models.py</files>
  <action>
Create the archive module with Pydantic data models for the archive system.

Create `core/archive/__init__.py` with module exports.

Create `core/archive/models.py` with these Pydantic models:

1. **WorkMetadata** - Metadata for a creative work
   - title: str (canonical title)
   - aliases: list[str] (alternate titles)
   - genre: str | None
   - year: int | None
   - isrc: str | None (for songs)
   - isbn: str | None (for books/compositions)
   - created_at: datetime
   - updated_at: datetime
   - notes: str | None

2. **Work** - A creative work (song, composition, etc.)
   - id: str (UUID format: work_{uuid8})
   - work_type: Literal["song", "composition", "script", "other"]
   - metadata: WorkMetadata
   - realizations: list[str] (realization IDs)
   - performances: list[str] (performance IDs)
   - assets: list[str] (asset paths)

3. **RealizationMetadata** - Metadata for a realization
   - name: str (e.g., "Studio Version", "Demo v1")
   - date: date | None
   - studio: str | None
   - engineer: str | None
   - producer: str | None
   - version: str | None
   - notes: str | None

4. **Realization** - A specific realization of a work
   - id: str (UUID format: real_{uuid8})
   - work_id: str (parent work)
   - metadata: RealizationMetadata
   - sessions: list[str] (DAW session file paths)
   - stems: list[str] (stem file paths)
   - masters: list[str] (master output paths)
   - created_at: datetime

5. **PerformanceMetadata** - Metadata for a performance
   - date: date
   - venue: str | None
   - city: str | None
   - personnel: list[str] (performers, crew)
   - setlist_position: int | None (for multi-song performances)
   - notes: str | None

6. **Performance** - A live performance or take
   - id: str (UUID format: perf_{uuid8})
   - work_id: str (parent work)
   - metadata: PerformanceMetadata
   - audio: list[str] (audio file paths)
   - video: list[str] (video file paths)
   - created_at: datetime

7. **AliasRegistry** - Global alias mapping
   - version: str = "1.0"
   - aliases: dict[str, str] (alias -> canonical_id)
   - conflicts: list[dict] (ambiguous aliases)

Follow Pydantic v2 syntax with `ConfigDict(from_attributes=True)`.
Use datetime from datetime module, date from datetime module.
</action>
  <verify>
python -c "from core.archive.models import Work, Realization, Performance, AliasRegistry; print('OK')"
</verify>
  <done>
core/archive/models.py defines Work, Realization, Performance, WorkMetadata, RealizationMetadata, PerformanceMetadata, and AliasRegistry with proper Pydantic v2 syntax.
</done>
</task>

</tasks>

<verification>
- [ ] .gitattributes contains filter=lfs for all media types
- [ ] core/archive/__init__.py exists and exports models
- [ ] core/archive/models.py imports without errors
- [ ] All 7 Pydantic models defined with required fields
</verification>

<success_criteria>
- Git LFS configured for 20+ file types
- Archive models importable and follow Pydantic v2 patterns
- Models include UUID-based IDs and proper datetime fields
</success_criteria>

<output>
After completion, create `.planning/phases/07-media-archive/07-01-SUMMARY.md`
</output>
