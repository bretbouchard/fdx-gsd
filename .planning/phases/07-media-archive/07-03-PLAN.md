---
phase: 07-media-archive
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - apps/cli/cli.py
autonomous: true

must_haves:
  truths:
    - "gsd archive init creates archive directory structure"
    - "Private repository template available"
  artifacts:
    - path: "apps/cli/cli.py"
      provides: "archive init command"
      exports: ["cmd_archive_init"]
  key_links:
    - from: "apps/cli/cli.py"
      to: "core/archive/"
      via: "import and call"
      pattern: "from core.archive"
---

<objective>
Add the `gsd archive init` command to initialize the archive directory structure.

Purpose: Provide a single command to set up the complete archive structure with all necessary directories and initial files.
Output: CLI subcommand that creates archive/ directory with works/, aliases.json, and index.json.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing CLI pattern
@apps/cli/cli.py - cmd_new_project pattern to follow

# Requirements reference
@.planning/REQUIREMENTS.md - ARC-06 (Private Repository Management)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Archive Init Command</name>
  <files>apps/cli/cli.py</files>
  <action>
Extend `apps/cli/cli.py` to add the `gsd archive init` command.

1. **Add cmd_archive_init function** following the pattern of cmd_new_project:

```python
def cmd_archive_init(args: argparse.Namespace) -> int:
    """
    Initialize archive directory structure.

    Usage: gsd archive init [--private]
    """
    project_path, exit_code = find_project_root()
    if exit_code != 0:
        print("Error: Not in a GSD project. Run 'gsd new-project' first.")
        return exit_code

    archive_path = project_path / "archive"

    if archive_path.exists() and not args.force:
        print(f"Error: Archive already exists at {archive_path}")
        print("Use --force to reinitialize")
        return 1

    # Create directory structure
    dirs = [
        archive_path / "works",
        archive_path / "works" / ".gitkeep",  # placeholder
    ]

    for d in dirs:
        if isinstance(d, type(archive_path)):  # it's a file path ending in .gitkeep
            d.parent.mkdir(parents=True, exist_ok=True)
            if not d.exists():
                d.write_text("# This directory contains work subdirectories\n")
        else:
            d.mkdir(parents=True, exist_ok=True)

    # Create aliases.json
    aliases_path = archive_path / "aliases.json"
    aliases_data = {
        "version": "1.0",
        "aliases": {},
        "conflicts": []
    }
    aliases_path.write_text(json.dumps(aliases_data, indent=2))

    # Create index.json
    index_path = archive_path / "index.json"
    index_data = {
        "version": "1.0",
        "updated_at": datetime.now().isoformat(),
        "works": {},
        "by_type": {}
    }
    index_path.write_text(json.dumps(index_data, indent=2))

    # Create README
    readme_path = archive_path / "README.md"
    readme_path.write_text("""# Media Archive

This directory contains archived media files for creative works.

## Structure

- `works/{work_id}/` - Each work has its own directory
  - `metadata.json` - Work metadata (title, aliases, etc.)
  - `realizations/` - Studio versions, demos, remixes
  - `performances/` - Live recordings, takes
  - `assets/` - Artwork, graphics, docs
- `aliases.json` - Global alias to canonical ID mapping
- `index.json` - Searchable index of all works

## Usage

```bash
gsd archive register "Song Title" --alias "Working Title"
gsd archive realize {work_id} --name "Studio Version"
gsd archive perform {work_id} --date 2026-02-19 --venue "Venue"
```

## Git LFS

Binary media files are handled by Git LFS. See .gitattributes for configured types.
""")

    # If --private flag, create .gitignore for sensitive files (optional future)
    if args.private:
        private_notes = archive_path / "PRIVATE.md"
        private_notes.write_text("""# Private Archive

This is a private archive. Ensure this repository is not publicly accessible.

## Access Control

- Repository should be private on GitHub/GitLab
- Limit collaborator access
- Consider encryption for sensitive media

## Backup Strategy

- Regular backups recommended
- Consider cloud storage for large media files
""")

    print(f"OK Initialized archive at: {archive_path}")
    print(f"  - Created works/ directory")
    print(f"  - Created aliases.json")
    print(f"  - Created index.json")
    print()
    print("Next: gsd archive register \"Song Title\"")

    return 0
```

2. **Add archive subparser** in main():

```python
# archive
p_archive = subparsers.add_parser("archive", help="Media archive commands")
archive_sub = p_archive.add_subparsers(dest="archive_command", help="Archive commands")

# archive init
p_archive_init = archive_sub.add_parser("init", help="Initialize archive")
p_archive_init.add_argument("--private", action="store_true", help="Create private archive")
p_archive_init.add_argument("--force", "-f", action="store_true", help="Reinitialize")
p_archive_init.set_defaults(func=cmd_archive_init, archive_command="init")
```

3. **Handle archive commands in main()** after args parsing:

```python
# Handle archive subcommands
if args.command == "archive":
    if not args.archive_command:
        p_archive.print_help()
        return 0
    return args.func(args)
```

Do NOT create the actual archive directory or files during this task - just the CLI command.
</action>
  <verify>
python -c "
import sys
sys.argv = ['gsd', 'archive', 'init', '--help']
# Should not raise
" && echo "CLI parses archive init command"
</verify>
  <done>
`gsd archive init` command creates archive/ directory structure with aliases.json and index.json.
</done>
</task>

</tasks>

<verification>
- [ ] `gsd archive init --help` shows usage
- [ ] cmd_archive_init function added to cli.py
- [ ] archive subparser with init subcommand registered
- [ ] Creates works/, aliases.json, index.json, README.md
</verification>

<success_criteria>
- CLI command parses correctly
- Directory structure matches ROADMAP specification
- Private flag creates PRIVATE.md with access control notes
</success_criteria>

<output>
After completion, create `.planning/phases/07-media-archive/07-03-SUMMARY.md`
</output>
