---
phase: 07-media-archive
plan: 06
type: execute
wave: 4
depends_on: ["07-04"]
files_modified:
  - core/archive/performance.py
  - apps/cli/cli.py
autonomous: true

must_haves:
  truths:
    - "gsd archive perform archives live performances"
    - "Audio and video files organized by performance"
    - "Personnel and venue tracked"
  artifacts:
    - path: "core/archive/performance.py"
      provides: "Performance archive management"
      exports: ["PerformanceManager"]
    - path: "apps/cli/cli.py"
      provides: "archive perform command"
  key_links:
    - from: "core/archive/performance.py"
      to: "archive/works/{work_id}/performances/"
      via: "file operations"
      pattern: "performances/"
---

<objective>
Implement performance archiving with the `gsd archive perform` command.

Purpose: Archive live performances and takes with audio/video recordings, venue information, and personnel tracking.
Output: PerformanceManager class and CLI command for archiving performances.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Required - models and registry from prior plans
@core/archive/models.py
@core/archive/registry.py

# CLI pattern
@apps/cli/cli.py

# Requirements reference
@.planning/REQUIREMENTS.md - ARC-03 (Performance Archive)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PerformanceManager</name>
  <files>core/archive/performance.py</files>
  <action>
Create `core/archive/performance.py` with a PerformanceManager class.

1. **Class PerformanceManager** with methods:
   - `__init__(self, archive_path: Path)` - initialize with archive directory
   - `create_performance(self, work_id: str, date: date, venue: str = None, city: str = None, personnel: list[str] = None, setlist_position: int = None, notes: str = None) -> Performance` - create new performance
   - `get_performance(self, performance_id: str) -> Performance | None` - retrieve performance
   - `list_performances(self, work_id: str) -> list[Performance]` - list all performances for a work
   - `add_audio(self, performance_id: str, file_path: Path, filename: str = None) -> str` - copy/add audio file
   - `add_video(self, performance_id: str, file_path: Path, filename: str = None) -> str` - copy/add video file
   - `delete_performance(self, performance_id: str) -> bool` - delete performance and files

2. **create_performance implementation**:
   - Verify work exists (raise ValueError if not)
   - Generate UUID: `perf_{uuid4().hex[:8]}`
   - Create performance directory: `archive/works/{work_id}/performances/{performance_id}/`
   - Create metadata.json in performance directory
   - Create subdirectories: audio/, video/
   - Update parent work's performances list
   - Return Performance model

3. **File handling**:
   - add_audio: Copy file to audio/, validate extension (.wav, .flac, .mp3, .aiff, .ogg, .m4a)
   - add_video: Copy file to video/, validate extension (.mp4, .mov, .avi, .mkv, .webm)
   - Return relative path within archive
   - Auto-rename if file exists (append _1, _2, etc.)

4. **Directory structure after performance**:
```
archive/works/{work_id}/
├── metadata.json
├── realizations/
├── performances/
│   └── perf_abc456/
│       ├── metadata.json
│       ├── audio/
│       │   └── live_2026-02-19.wav
│       └── video/
│           └── live_2026-02-19.mp4
└── assets/
```

5. **Use imports**:
   - from core.archive.models import Performance, PerformanceMetadata
   - from core.archive.registry import WorkRegistry
   - import shutil for file copying
</action>
  <verify>
python -c "
from pathlib import Path
from core.archive.performance import PerformanceManager
from core.archive.registry import WorkRegistry
from tempfile import TemporaryDirectory
from datetime import date
with TemporaryDirectory() as tmp:
    reg = WorkRegistry(Path(tmp))
    w = reg.register_work('Test Song')
    pm = PerformanceManager(Path(tmp))
    p = pm.create_performance(w.id, date=date.today(), venue='Test Venue')
    assert p.id.startswith('perf_')
    assert p.metadata.venue == 'Test Venue'
    print('OK')
"
</verify>
  <done>
PerformanceManager creates performances with audio/ and video/ directories.
</done>
</task>

<task type="auto">
  <name>Task 2: Add Archive Perform Command</name>
  <files>apps/cli/cli.py</files>
  <action>
Add the `gsd archive perform` command to the CLI.

1. **Add cmd_archive_perform function**:

```python
def cmd_archive_perform(args: argparse.Namespace) -> int:
    """
    Archive a live performance.

    Usage: gsd archive perform {work_id} --date YYYY-MM-DD [options]
    """
    project_path, exit_code = find_project_root()
    if exit_code != 0:
        print("Error: Not in a GSD project.")
        return exit_code

    archive_path = project_path / "archive"
    if not archive_path.exists():
        print("Error: Archive not initialized.")
        return 1

    from core.archive.performance import PerformanceManager
    from core.archive.registry import WorkRegistry
    from datetime import datetime as dt

    # Resolve work_id (might be alias)
    registry = WorkRegistry(archive_path)
    work = registry.get_work_by_alias(args.work_id)
    if not work:
        work = registry.get_work(args.work_id)

    if not work:
        print(f"Error: Work not found: {args.work_id}")
        return 1

    # Parse date (required)
    try:
        perf_date = dt.strptime(args.date, "%Y-%m-%d").date()
    except ValueError:
        print(f"Error: Invalid date format. Use YYYY-MM-DD")
        return 1

    # Parse personnel
    personnel = args.personnel if args.personnel else []

    # Create performance
    manager = PerformanceManager(archive_path)
    try:
        performance = manager.create_performance(
            work_id=work.id,
            date=perf_date,
            venue=args.venue,
            city=args.city,
            personnel=personnel,
            setlist_position=args.position,
            notes=args.notes
        )

        print(f"OK Archived performance")
        print(f"  Work: {work.metadata.title}")
        print(f"  Date: {perf_date}")
        print(f"  ID: {performance.id}")
        if args.venue:
            print(f"  Venue: {args.venue}")
        if args.city:
            print(f"  City: {args.city}")
        if personnel:
            print(f"  Personnel: {', '.join(personnel)}")
        print()
        print(f"Add files:")
        print(f"  cp recording.wav {archive_path}/works/{work.id}/performances/{performance.id}/audio/")
        print(f"  cp video.mp4 {archive_path}/works/{work.id}/performances/{performance.id}/video/")

        return 0

    except ValueError as e:
        print(f"Error: {e}")
        return 1
```

2. **Add perform subparser** to archive_sub:

```python
# archive perform
p_perform = archive_sub.add_parser("perform", help="Archive a live performance")
p_perform.add_argument("work_id", help="Work ID or alias")
p_perform.add_argument("--date", "-d", required=True, help="Performance date (YYYY-MM-DD)")
p_perform.add_argument("--venue", "-v", help="Venue name")
p_perform.add_argument("--city", "-c", help="City")
p_perform.add_argument("--personnel", "-p", action="append", help="Personnel (can use multiple times)")
p_perform.add_argument("--position", type=int, help="Setlist position")
p_perform.add_argument("--notes", "-n", help="Additional notes")
p_perform.set_defaults(func=cmd_archive_perform, archive_command="perform")
```
</action>
  <verify>
python -c "
import sys
sys.argv = ['gsd', 'archive', 'perform', '--help']
# Should show help with --date, --venue, --city options
" && echo "CLI parses archive perform command"
</verify>
  <done>
`gsd archive perform {work_id} --date 2026-02-19 --venue "Venue"` archives performance.
</done>
</task>

</tasks>

<verification>
- [ ] PerformanceManager.create_performance creates performance directory
- [ ] PerformanceManager creates audio/ and video/ subdirectories
- [ ] CLI `gsd archive perform` requires --date
- [ ] Performance metadata includes venue, city, personnel
- [ ] Parent work's performances list updated
</verification>

<success_criteria>
- Performances organized by work and date
- Audio/video directories created
- Personnel list supported (repeatable --personnel)
- Venue and city metadata captured
</success_criteria>

<output>
After completion, create `.planning/phases/07-media-archive/07-06-SUMMARY.md`
</output>
