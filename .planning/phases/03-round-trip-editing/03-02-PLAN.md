---
phase: 03-round-trip-editing
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - core/sync/conflict_resolver.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Safe changes (array additions) are auto-merged"
    - "Ambiguous changes are flagged for user review"
    - "Critical changes (ID/type) block the operation"
    - "Conflicts are persisted to build/conflicts.json"
  artifacts:
    - path: "core/sync/conflict_resolver.py"
      provides: "Three-tier conflict resolution"
      exports: ["ConflictResolver", "Conflict", "ConflictTier"]
    - path: "build/conflicts.json"
      provides: "Persisted conflicts for review"
  key_links:
    - from: "core/sync/conflict_resolver.py"
      to: "build/conflicts.json"
      via: "JSON persistence"
      pattern: "conflicts\\.json"
    - from: "core/sync/conflict_resolver.py"
      to: "core/sync/provenance.py"
      via: "uses SourceType for conflict context"
      pattern: "SourceType"
---

<objective>
Implement three-tier conflict resolution for handling vault vs extraction conflicts.

Purpose: Round-trip editing requires intelligent handling of conflicts. Safe changes auto-merge, ambiguous changes flag for review, critical changes block to prevent data loss.
Output: ConflictResolver class that categorizes and persists conflicts.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Research context
@.planning/phases/03-round-trip-editing/03-RESEARCH.md

# Dependencies from Plan 01
@core/sync/provenance.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conflict resolver module</name>
  <files>core/sync/conflict_resolver.py</files>
  <action>
Create three-tier conflict resolution module:

```python
"""Conflict resolution for vault vs extraction conflicts.

Three-tier resolution strategy:
  SAFE: Auto-merge (e.g., new aliases added to character)
  AMBIGUOUS: Flag for review (e.g., same field changed in both places)
  CRITICAL: Block + prompt (e.g., entity ID collision)
"""
import json
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional


class ConflictTier(Enum):
    """Severity of conflict."""
    SAFE = "safe"           # Auto-merge allowed
    AMBIGUOUS = "ambiguous" # Flag for user review
    CRITICAL = "critical"   # Block operation, require user action


class ConflictStatus(Enum):
    """Status of conflict resolution."""
    PENDING = "pending"
    RESOLVED_AUTO = "resolved_auto"
    RESOLVED_MANUAL = "resolved_manual"
    IGNORED = "ignored"


@dataclass
class Conflict:
    """Represents a detected conflict between vault and extraction."""
    id: str
    tier: ConflictTier
    status: ConflictStatus = ConflictStatus.PENDING
    entity_id: str = ""
    entity_type: str = ""
    field: str = ""
    vault_value: Any = None
    extracted_value: Any = None
    source_file: str = ""
    vault_file: str = ""
    evidence_ids: List[str] = field(default_factory=list)
    message: str = ""
    resolution: Optional[str] = None
    resolved_value: Any = None
    created_at: str = ""
    resolved_at: Optional[str] = None

    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "tier": self.tier.value,
            "status": self.status.value,
            "entity_id": self.entity_id,
            "entity_type": self.entity_type,
            "field": self.field,
            "vault_value": self.vault_value,
            "extracted_value": self.extracted_value,
            "source_file": self.source_file,
            "vault_file": self.vault_file,
            "evidence_ids": self.evidence_ids,
            "message": self.message,
            "resolution": self.resolution,
            "resolved_value": self.resolved_value,
            "created_at": self.created_at,
            "resolved_at": self.resolved_at
        }

    @classmethod
    def from_dict(cls, data: dict) -> "Conflict":
        return cls(
            id=data["id"],
            tier=ConflictTier(data["tier"]),
            status=ConflictStatus(data.get("status", "pending")),
            entity_id=data.get("entity_id", ""),
            entity_type=data.get("entity_type", ""),
            field=data.get("field", ""),
            vault_value=data.get("vault_value"),
            extracted_value=data.get("extracted_value"),
            source_file=data.get("source_file", ""),
            vault_file=data.get("vault_file", ""),
            evidence_ids=data.get("evidence_ids", []),
            message=data.get("message", ""),
            resolution=data.get("resolution"),
            resolved_value=data.get("resolved_value"),
            created_at=data.get("created_at", ""),
            resolved_at=data.get("resolved_at")
        )


class ConflictResolver:
    """Handle conflicts during re-ingestion."""

    # Fields that are safe to add to (arrays)
    ADDITIVE_FIELDS = {"aliases", "evidence_ids", "tags"}

    # Fields that should never be auto-changed
    CRITICAL_FIELDS = {"id", "type"}

    def __init__(self, conflicts_path: Path):
        self.conflicts_path = Path(conflicts_path)
        self.conflicts: List[Conflict] = []
        self._conflict_counter = 0
        self._load()

    def _load(self):
        """Load existing conflicts."""
        if self.conflicts_path.exists():
            data = json.loads(self.conflicts_path.read_text())
            for conflict_data in data.get("conflicts", []):
                conflict = Conflict.from_dict(conflict_data)
                self.conflicts.append(conflict)
                # Update counter for unique IDs
                if conflict.id.startswith("conf_"):
                    try:
                        num = int(conflict.id.split("_")[1])
                        self._conflict_counter = max(self._conflict_counter, num)
                    except (IndexError, ValueError):
                        pass

    def _save(self):
        """Persist conflicts to disk."""
        self.conflicts_path.parent.mkdir(parents=True, exist_ok=True)
        data = {
            "version": "1.0",
            "updated_at": datetime.now().isoformat(),
            "conflicts": [c.to_dict() for c in self.conflicts]
        }
        self.conflicts_path.write_text(json.dumps(data, indent=2))

    def _next_id(self) -> str:
        """Generate next conflict ID."""
        self._conflict_counter += 1
        return f"conf_{self._conflict_counter:04d}"

    def classify_conflict(
        self,
        field: str,
        vault_value: Any,
        extracted_value: Any
    ) -> ConflictTier:
        """Classify conflict severity based on field and values."""

        # CRITICAL: Entity ID or type changes
        if field in self.CRITICAL_FIELDS:
            if vault_value != extracted_value:
                return ConflictTier.CRITICAL
            return ConflictTier.SAFE  # No actual conflict

        # SAFE: No actual difference
        if vault_value == extracted_value:
            return ConflictTier.SAFE

        # SAFE: Additive changes to arrays
        if field in self.ADDITIVE_FIELDS:
            if isinstance(vault_value, list) and isinstance(extracted_value, list):
                vault_set = set(vault_value)
                extracted_set = set(extracted_value)
                # Only additions from extraction - safe
                if extracted_set - vault_set and not vault_set - extracted_set:
                    return ConflictTier.SAFE
                # Only additions from vault - safe
                if vault_set - extracted_set and not extracted_set - vault_set:
                    return ConflictTier.SAFE
                # Both have unique items - still safe (union)
                return ConflictTier.SAFE

        # AMBIGUOUS: Everything else (scalar field changed in both)
        return ConflictTier.AMBIGUOUS

    def detect_conflict(
        self,
        entity_id: str,
        entity_type: str,
        field: str,
        vault_value: Any,
        extracted_value: Any,
        source_file: str = "",
        vault_file: str = "",
        evidence_ids: List[str] = None
    ) -> Optional[Conflict]:
        """
        Detect if there's a conflict between vault and extraction.

        Returns:
            Conflict if one exists, None if values match
        """
        evidence_ids = evidence_ids or []

        # No conflict if values match
        if vault_value == extracted_value:
            return None

        tier = self.classify_conflict(field, vault_value, extracted_value)

        # Create conflict record
        conflict = Conflict(
            id=self._next_id(),
            tier=tier,
            entity_id=entity_id,
            entity_type=entity_type,
            field=field,
            vault_value=vault_value,
            extracted_value=extracted_value,
            source_file=source_file,
            vault_file=vault_file,
            evidence_ids=evidence_ids,
            message=self._generate_message(tier, field, vault_value, extracted_value)
        )

        self.conflicts.append(conflict)
        self._save()

        return conflict

    def _generate_message(
        self,
        tier: ConflictTier,
        field: str,
        vault_value: Any,
        extracted_value: Any
    ) -> str:
        """Generate human-readable conflict message."""
        if tier == ConflictTier.SAFE:
            return f"Safe: {field} has additions to merge"
        elif tier == ConflictTier.CRITICAL:
            return f"CRITICAL: {field} changed from '{vault_value}' to '{extracted_value}'"
        else:
            return f"Ambiguous: {field} differs (vault: '{vault_value}', extraction: '{extracted_value}')"

    def resolve_safe(self, conflict: Conflict) -> Any:
        """
        Auto-resolve a safe conflict by merging values.

        For arrays: return union of both
        For scalars: prefer extracted_value (newer data)
        """
        if conflict.tier != ConflictTier.SAFE:
            raise ValueError(f"Cannot auto-resolve non-safe conflict: {conflict.tier}")

        vault_val = conflict.vault_value
        extracted_val = conflict.extracted_value

        if isinstance(vault_val, list) and isinstance(extracted_val, list):
            # Merge arrays
            resolved = sorted(set(vault_val) | set(extracted_val))
        else:
            # For scalars, prefer extracted (newer data wins)
            resolved = extracted_val

        # Update conflict
        conflict.status = ConflictStatus.RESOLVED_AUTO
        conflict.resolution = "auto-merged"
        conflict.resolved_value = resolved
        conflict.resolved_at = datetime.now().isoformat()

        self._save()
        return resolved

    def resolve_manual(
        self,
        conflict_id: str,
        resolved_value: Any,
        resolution_note: str = ""
    ) -> Optional[Conflict]:
        """
        Manually resolve a conflict.

        Args:
            conflict_id: ID of conflict to resolve
            resolved_value: The chosen value
            resolution_note: Optional note about resolution

        Returns:
            Updated conflict, or None if not found
        """
        for conflict in self.conflicts:
            if conflict.id == conflict_id:
                conflict.status = ConflictStatus.RESOLVED_MANUAL
                conflict.resolution = resolution_note or "manual"
                conflict.resolved_value = resolved_value
                conflict.resolved_at = datetime.now().isoformat()
                self._save()
                return conflict
        return None

    def get_pending_conflicts(self) -> List[Conflict]:
        """Get all pending (non-resolved) conflicts."""
        return [c for c in self.conflicts if c.status == ConflictStatus.PENDING]

    def get_critical_conflicts(self) -> List[Conflict]:
        """Get all critical-tier conflicts."""
        return [c for c in self.conflicts if c.tier == ConflictTier.CRITICAL]

    def get_ambiguous_conflicts(self) -> List[Conflict]:
        """Get all ambiguous-tier conflicts."""
        return [c for c in self.conflicts if c.tier == ConflictTier.AMBIGUOUS]

    def has_blocking_conflicts(self) -> bool:
        """Check if there are any unresolved critical conflicts."""
        return any(
            c.tier == ConflictTier.CRITICAL and c.status == ConflictStatus.PENDING
            for c in self.conflicts
        )

    def clear_resolved(self):
        """Remove all resolved conflicts from memory (keep in file)."""
        self.conflicts = [c for c in self.conflicts if c.status == ConflictStatus.PENDING]
        self._save()
</action>
  <verify>python -c "from core.sync.conflict_resolver import ConflictResolver, Conflict, ConflictTier; print('Import OK')"</verify>
  <done>ConflictResolver can detect, classify, and resolve conflicts with three tiers</done>
</task>

</tasks>

<verification>
- ConflictResolver imports successfully
- Can classify conflicts into SAFE/AMBIGUOUS/CRITICAL
- Can auto-resolve safe conflicts (array merging)
- Conflicts persist to build/conflicts.json
</verification>

<success_criteria>
- `core/sync/conflict_resolver.py` with ConflictResolver, Conflict, ConflictTier classes
- Three-tier classification logic working
- Conflict persistence to JSON
- Auto-merge for array fields (aliases, evidence_ids)
</success_criteria>

<output>
After completion, create `.planning/phases/03-round-trip-editing/03-02-SUMMARY.md`
</output>
