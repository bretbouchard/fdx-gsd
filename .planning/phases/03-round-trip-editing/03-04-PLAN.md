---
phase: 03-round-trip-editing
plan: 04
type: execute
wave: 4
depends_on: ["03-03"]
files_modified:
  - core/vault/note_writer.py
  - tests/unit/test_sync.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "VaultNoteWriter preserves user content outside protected blocks"
    - "Rebuilds replace only protected block content"
    - "Manual edits survive rebuild operations"
  artifacts:
    - path: "core/vault/note_writer.py"
      provides: "Protected block-aware note writing"
      exports: ["VaultNoteWriter"]
    - path: "tests/unit/test_sync.py"
      provides: "Unit tests for sync module"
  key_links:
    - from: "core/vault/note_writer.py"
      to: "core/sync/protected_blocks.py"
      via: "replace_protected_content"
      pattern: "replace_protected"
    - from: "core/vault/note_writer.py"
      to: "core/vault/templates.py"
      via: "render_*_template functions"
      pattern: "render_.*_template"
---

<objective>
Update VaultNoteWriter to use protected block replacement instead of full file overwrite.

Purpose: The current VaultNoteWriter overwrites entire files, which would destroy user annotations. We need to update it to use protected block replacement so manual edits are preserved on rebuild.
Output: Updated VaultNoteWriter with protected block awareness.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Dependencies from Plans 01-03
@core/sync/protected_blocks.py

# Existing implementation
@core/vault/note_writer.py
@core/vault/templates.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update VaultNoteWriter for protected block replacement</name>
  <files>core/vault/note_writer.py</files>
  <action>
Update VaultNoteWriter to preserve user content by using protected block replacement:

1. Modify `core/vault/note_writer.py`:

```python
"""Vault note writer - Generates Obsidian-compatible markdown notes.

Writes entity notes to vault directories with evidence links.
Uses protected block replacement to preserve manual edits.
"""
import json
from pathlib import Path
from typing import Dict, List, Optional, Any

from .templates import (
    render_character_template,
    render_location_template,
    render_scene_template,
    _slugify,
)
from ..sync.protected_blocks import (
    replace_protected_content,
    extract_protected_content,
    has_protected_block,
    ensure_markers,
)


class VaultNoteWriter:
    """Writes entity notes to the Obsidian vault.

    Uses protected block replacement to preserve user edits outside
    <!-- CONFUCIUS:BEGIN AUTO --> ... <!-- CONFUCIUS:END AUTO --> markers.
    """

    def __init__(self, vault_path: Path, build_path: Path = None):
        """
        Initialize the vault note writer.

        Args:
            vault_path: Path to the vault root
            build_path: Path to build directory (for evidence index)
        """
        self.vault_path = Path(vault_path)
        self.build_path = Path(build_path) if build_path else self.vault_path.parent / "build"
        self._evidence_index = None

        # Ensure directories exist
        self._ensure_directories()

    def _ensure_directories(self):
        """Create vault subdirectories if they don't exist."""
        dirs = [
            self.vault_path / "10_Characters",
            self.vault_path / "20_Locations",
            self.vault_path / "50_Scenes",
        ]
        for d in dirs:
            d.mkdir(parents=True, exist_ok=True)

    def _load_evidence_index(self) -> dict:
        """Load the evidence index for link resolution."""
        if self._evidence_index is None:
            path = self.build_path / "evidence_index.json"
            if path.exists():
                self._evidence_index = json.loads(path.read_text())
            else:
                self._evidence_index = {"evidence": {}}
        return self._evidence_index

    def format_evidence_links(self, evidence_ids: List[str]) -> str:
        """
        Convert evidence IDs to Obsidian wikilinks.

        Args:
            evidence_ids: List of block refs (e.g., ["ev_a1b2", "ev_c3d4"])

        Returns:
            Formatted markdown list of wikilinks
        """
        if not evidence_ids:
            return ""

        index = self._load_evidence_index()
        links = []

        for ev_id in evidence_ids:
            ev_data = index.get("evidence", {}).get(ev_id, {})
            source = ev_data.get("source_path", "unknown")
            link = f"[[{source}#^{ev_id}]]"
            links.append(link)

        return "\n".join(f"- {link}" for link in links)

    def _write_with_protection(
        self,
        file_path: Path,
        new_protected_content: str,
        full_template_content: str = None
    ) -> Path:
        """
        Write file using protected block replacement.

        If file exists, preserves content outside protected blocks.
        If file doesn't exist, creates from template.

        Args:
            file_path: Target file path
            new_protected_content: Content for protected region (without markers)
            full_template_content: Optional full template for new files

        Returns:
            Path to written file
        """
        if file_path.exists():
            # Read existing content
            existing = file_path.read_text(encoding="utf-8")

            # Ensure markers exist
            if not has_protected_block(existing):
                existing = ensure_markers(existing)

            # Replace only protected content
            updated = replace_protected_content(existing, new_protected_content)
            file_path.write_text(updated, encoding="utf-8")
        else:
            # New file - use template
            if full_template_content:
                file_path.write_text(full_template_content, encoding="utf-8")
            else:
                # Fallback: create with markers
                content = f"\n{new_protected_content}\n"
                file_path.write_text(ensure_markers(content), encoding="utf-8")

        return file_path

    def _extract_protected_from_template(
        self,
        template_content: str
    ) -> str:
        """
        Extract protected block content from full template.

        Returns content between markers (without markers).
        """
        _, protected, _ = extract_protected_content(template_content)
        return protected

    def write_character(self, entity: Dict[str, Any]) -> Path:
        """
        Write a character note to the vault.

        Uses protected block replacement to preserve manual edits.

        Args:
            entity: Entity dict with id, name, aliases, evidence_ids, etc.

        Returns:
            Path to the written file
        """
        name = entity.get("name", "unknown")
        slug = _slugify(name)
        file_path = self.vault_path / "10_Characters" / f"{slug}.md"

        # Format evidence links
        evidence_ids = entity.get("evidence_ids", [])
        evidence_links = self.format_evidence_links(evidence_ids)

        # Render full template (for new files)
        full_template = render_character_template(entity, evidence_links)

        # Extract protected content for replacement
        protected_content = self._extract_protected_from_template(full_template)

        # Write with protection
        return self._write_with_protection(file_path, protected_content, full_template)

    def write_location(self, entity: Dict[str, Any]) -> Path:
        """
        Write a location note to the vault.

        Uses protected block replacement to preserve manual edits.

        Args:
            entity: Entity dict with id, name, attributes, evidence_ids, etc.

        Returns:
            Path to the written file
        """
        name = entity.get("name", "unknown")
        slug = _slugify(name)
        file_path = self.vault_path / "20_Locations" / f"{slug}.md"

        # Format evidence links
        evidence_ids = entity.get("evidence_ids", [])
        evidence_links = self.format_evidence_links(evidence_ids)

        # Render full template (for new files)
        full_template = render_location_template(entity, evidence_links)

        # Extract protected content for replacement
        protected_content = self._extract_protected_from_template(full_template)

        # Write with protection
        return self._write_with_protection(file_path, protected_content, full_template)

    def write_scene(self, entity: Dict[str, Any]) -> Path:
        """
        Write a scene note to the vault.

        Uses protected block replacement to preserve manual edits.

        Args:
            entity: Entity dict with id, name, attributes, evidence_ids, etc.

        Returns:
            Path to the written file
        """
        scene_id = entity.get("id", "SCN_000")
        file_path = self.vault_path / "50_Scenes" / f"{scene_id}.md"

        # Format evidence links
        evidence_ids = entity.get("evidence_ids", [])
        evidence_links = self.format_evidence_links(evidence_ids)

        # Render full template (for new files)
        full_template = render_scene_template(entity, evidence_links)

        # Extract protected content for replacement
        protected_content = self._extract_protected_from_template(full_template)

        # Write with protection
        return self._write_with_protection(file_path, protected_content, full_template)

    def write_entity(self, entity: Dict[str, Any]) -> Optional[Path]:
        """
        Write any entity to the appropriate vault location.

        Args:
            entity: Entity dict with 'type' field

        Returns:
            Path to written file, or None if unknown type
        """
        entity_type = entity.get("type", "")

        if entity_type == "character":
            return self.write_character(entity)
        elif entity_type == "location":
            return self.write_location(entity)
        elif entity_type == "scene":
            return self.write_scene(entity)

        return None


def write_entity_note(entity: Dict[str, Any], vault_path: Path, build_path: Path = None) -> Optional[Path]:
    """
    Convenience function to write an entity note.

    Args:
        entity: Entity dict
        vault_path: Path to vault root
        build_path: Optional path to build directory

    Returns:
        Path to written file
    """
    writer = VaultNoteWriter(vault_path, build_path)
    return writer.write_entity(entity)
```
</action>
  <verify>python -c "from core.vault.note_writer import VaultNoteWriter; print('Import OK')"</verify>
  <done>VaultNoteWriter uses protected block replacement to preserve manual edits</done>
</task>

<task type="auto">
  <name>Task 2: Create sync module unit tests</name>
  <files>tests/unit/test_sync.py</files>
  <action>
Create comprehensive unit tests for the sync module:

```python
"""Unit tests for sync module (round-trip editing)."""
import hashlib
import json
import tempfile
from pathlib import Path

import pytest

from core.sync.change_detector import ChangeDetector, calculate_file_hash
from core.sync.protected_blocks import (
    BEGIN_MARKER,
    END_MARKER,
    extract_protected_content,
    replace_protected_content,
    ensure_markers,
    has_protected_block,
    extract_frontmatter,
    parse_frontmatter_yaml,
)
from core.sync.provenance import ProvenanceTracker, ProvenanceRecord, SourceType
from core.sync.conflict_resolver import (
    ConflictResolver,
    Conflict,
    ConflictTier,
    ConflictStatus,
)
from core.sync.reingest import VaultReingester, ReingestResult


class TestChangeDetector:
    """Tests for change detection."""

    def test_calculate_file_hash(self, tmp_path):
        """Test SHA-256 hash calculation."""
        test_file = tmp_path / "test.md"
        test_file.write_text("test content")

        hash1 = calculate_file_hash(test_file)
        hash2 = calculate_file_hash(test_file)

        # Same content = same hash
        assert hash1 == hash2
        assert len(hash1) == 64  # SHA-256 hex length

    def test_hash_changes_with_content(self, tmp_path):
        """Test that hash changes when content changes."""
        test_file = tmp_path / "test.md"
        test_file.write_text("original content")

        hash1 = calculate_file_hash(test_file)

        test_file.write_text("modified content")
        hash2 = calculate_file_hash(test_file)

        assert hash1 != hash2

    def test_has_changed_detects_change(self, tmp_path):
        """Test has_changed returns True for modified files."""
        state_path = tmp_path / "run_state.json"
        detector = ChangeDetector(state_path)

        test_file = tmp_path / "test.md"
        test_file.write_text("original")
        detector.mark_synced(test_file)

        # No change
        assert not detector.has_changed(test_file)

        # Modify
        test_file.write_text("modified")
        assert detector.has_changed(test_file)

    def test_get_changed_files(self, tmp_path):
        """Test getting all changed files in directory."""
        state_path = tmp_path / "run_state.json"
        detector = ChangeDetector(state_path)

        # Create files
        (tmp_path / "file1.md").write_text("content1")
        (tmp_path / "file2.md").write_text("content2")

        # Mark synced
        detector.mark_all_synced(tmp_path)

        # Modify one
        (tmp_path / "file1.md").write_text("modified")

        changed = detector.get_changed_files(tmp_path)
        assert len(changed) == 1
        assert changed[0].name == "file1.md"


class TestProtectedBlocks:
    """Tests for protected block parsing."""

    def test_has_protected_block_true(self):
        """Test detection of protected blocks."""
        content = f"Some text\n{BEGIN_MARKER}\nprotected\n{END_MARKER}\nmore"
        assert has_protected_block(content) is True

    def test_has_protected_block_false(self):
        """Test detection when no protected blocks."""
        content = "Some text\nNo markers here"
        assert has_protected_block(content) is False

    def test_extract_protected_content(self):
        """Test extraction of protected content."""
        content = f"before\n{BEGIN_MARKER}\nprotected content\n{END_MARKER}\nafter"
        before, protected, after = extract_protected_content(content)

        assert "before" in before
        assert protected == "protected content"
        assert "after" in after

    def test_extract_protected_content_no_markers(self):
        """Test extraction when no markers present."""
        content = "just content, no markers"
        before, protected, after = extract_protected_content(content)

        assert before == content
        assert protected == ""
        assert after == ""

    def test_replace_protected_content(self):
        """Test replacing protected content."""
        content = f"before\n{BEGIN_MARKER}\nold\n{END_MARKER}\nafter"
        new = replace_protected_content(content, "new content")

        assert "before" in new
        assert "new content" in new
        assert "old" not in new
        assert "after" in new

    def test_replace_protected_no_markers_appends(self):
        """Test that missing markers cause append."""
        content = "just content"
        result = replace_protected_content(content, "new")

        assert BEGIN_MARKER in result
        assert END_MARKER in result
        assert "new" in result

    def test_ensure_markers_adds_if_missing(self):
        """Test ensure_markers adds markers when missing."""
        content = "no markers"
        result = ensure_markers(content)

        assert BEGIN_MARKER in result
        assert END_MARKER in result

    def test_ensure_markers_preserves_existing(self):
        """Test ensure_markers doesn't duplicate markers."""
        content = f"content\n{BEGIN_MARKER}\n{END_MARKER}"
        result = ensure_markers(content)

        # Should not double the markers
        assert result.count(BEGIN_MARKER) == 1
        assert result.count(END_MARKER) == 1

    def test_extract_frontmatter(self):
        """Test YAML frontmatter extraction."""
        content = "---\nid: CHAR_001\nname: John\n---\n\nBody content"
        fm, body = extract_frontmatter(content)

        assert fm == "id: CHAR_001\nname: John"
        assert "Body content" in body

    def test_extract_frontmatter_none(self):
        """Test frontmatter extraction with no frontmatter."""
        content = "No frontmatter here"
        fm, body = extract_frontmatter(content)

        assert fm is None
        assert body == content

    def test_parse_frontmatter_yaml(self):
        """Test YAML frontmatter parsing."""
        yaml = "id: CHAR_001\nname: John\naliases: [Johnny, J]\nactive: true"
        result = parse_frontmatter_yaml(yaml)

        assert result["id"] == "CHAR_001"
        assert result["name"] == "John"
        assert result["aliases"] == ["Johnny", "J"]
        assert result["active"] is True


class TestProvenance:
    """Tests for provenance tracking."""

    def test_track_extraction(self, tmp_path):
        """Test tracking extraction provenance."""
        tracker = ProvenanceTracker(tmp_path / "provenance.json")

        record = tracker.track_extraction(
            content="John",
            entity_id="CHAR_001",
            field="name",
            source_file="inbox/note1.md",
            evidence_ids=["ev_001"]
        )

        assert record.source_type == SourceType.EXTRACTION
        assert record.entity_id == "CHAR_001"
        assert record.field == "name"
        assert record.source_file == "inbox/note1.md"

    def test_track_manual_edit(self, tmp_path):
        """Test tracking manual edit provenance."""
        tracker = ProvenanceTracker(tmp_path / "provenance.json")

        record = tracker.track_manual_edit(
            content="Johnny",
            entity_id="CHAR_001",
            field="name",
            vault_file="vault/10_Characters/john.md"
        )

        assert record.source_type == SourceType.MANUAL_EDIT
        assert record.vault_file == "vault/10_Characters/john.md"

    def test_get_source(self, tmp_path):
        """Test retrieving provenance by entity/field."""
        tracker = ProvenanceTracker(tmp_path / "provenance.json")

        tracker.track_extraction(
            content="John",
            entity_id="CHAR_001",
            field="name",
            source_file="inbox/note1.md",
            evidence_ids=[]
        )

        record = tracker.get_source("CHAR_001", "name")
        assert record is not None
        assert record.content_hash != ""

    def test_has_changed_since_extraction(self, tmp_path):
        """Test detecting manual changes after extraction."""
        tracker = ProvenanceTracker(tmp_path / "provenance.json")

        # Track extraction
        tracker.track_extraction(
            content="John",
            entity_id="CHAR_001",
            field="name",
            source_file="inbox/note1.md",
            evidence_ids=[]
        )

        assert not tracker.has_changed_since_extraction("CHAR_001", "name")

        # Track manual edit
        tracker.track_manual_edit(
            content="Johnny",
            entity_id="CHAR_001",
            field="name",
            vault_file="vault/10_Characters/john.md"
        )

        assert tracker.has_changed_since_extraction("CHAR_001", "name")


class TestConflictResolver:
    """Tests for conflict resolution."""

    def test_classify_safe_array_addition(self, tmp_path):
        """Test SAFE tier for array additions."""
        resolver = ConflictResolver(tmp_path / "conflicts.json")

        tier = resolver.classify_conflict(
            field="aliases",
            vault_value=["John"],
            extracted_value=["John", "Johnny"]
        )

        assert tier == ConflictTier.SAFE

    def test_classify_critical_id_change(self, tmp_path):
        """Test CRITICAL tier for ID changes."""
        resolver = ConflictResolver(tmp_path / "conflicts.json")

        tier = resolver.classify_conflict(
            field="id",
            vault_value="CHAR_001",
            extracted_value="CHAR_002"
        )

        assert tier == ConflictTier.CRITICAL

    def test_classify_ambiguous_scalar(self, tmp_path):
        """Test AMBIGUOUS tier for scalar field changes."""
        resolver = ConflictResolver(tmp_path / "conflicts.json")

        tier = resolver.classify_conflict(
            field="name",
            vault_value="John",
            extracted_value="Jonathan"
        )

        assert tier == ConflictTier.AMBIGUOUS

    def test_detect_conflict_creates_record(self, tmp_path):
        """Test that detect_conflict creates conflict record."""
        resolver = ConflictResolver(tmp_path / "conflicts.json")

        conflict = resolver.detect_conflict(
            entity_id="CHAR_001",
            entity_type="character",
            field="name",
            vault_value="John",
            extracted_value="Jonathan"
        )

        assert conflict is not None
        assert conflict.tier == ConflictTier.AMBIGUOUS
        assert len(resolver.conflicts) == 1

    def test_no_conflict_same_values(self, tmp_path):
        """Test no conflict when values match."""
        resolver = ConflictResolver(tmp_path / "conflicts.json")

        conflict = resolver.detect_conflict(
            entity_id="CHAR_001",
            entity_type="character",
            field="name",
            vault_value="John",
            extracted_value="John"
        )

        assert conflict is None

    def test_resolve_safe_merges_arrays(self, tmp_path):
        """Test auto-resolve merges array values."""
        resolver = ConflictResolver(tmp_path / "conflicts.json")

        conflict = resolver.detect_conflict(
            entity_id="CHAR_001",
            entity_type="character",
            field="aliases",
            vault_value=["John", "Johnny"],
            extracted_value=["John", "J"]
        )

        resolved = resolver.resolve_safe(conflict)

        assert "John" in resolved
        assert "Johnny" in resolved
        assert "J" in resolved
        assert conflict.status == ConflictStatus.RESOLVED_AUTO

    def test_get_pending_conflicts(self, tmp_path):
        """Test filtering pending conflicts."""
        resolver = ConflictResolver(tmp_path / "conflicts.json")

        resolver.detect_conflict("C1", "character", "name", "A", "B")
        resolver.detect_conflict("C2", "character", "name", "X", "Y")

        pending = resolver.get_pending_conflicts()
        assert len(pending) == 2

    def test_has_blocking_conflicts(self, tmp_path):
        """Test blocking conflict detection."""
        resolver = ConflictResolver(tmp_path / "conflicts.json")

        # No blocking conflicts initially
        assert not resolver.has_blocking_conflicts()

        # Add critical conflict
        resolver.detect_conflict(
            entity_id="C1",
            entity_type="character",
            field="id",
            vault_value="C1",
            extracted_value="C2"
        )

        assert resolver.has_blocking_conflicts()


class TestVaultReingester:
    """Tests for vault re-ingestion."""

    @pytest.fixture
    def project(self, tmp_path):
        """Create a minimal project structure."""
        vault = tmp_path / "vault"
        build = tmp_path / "build"
        chars = vault / "10_Characters"

        chars.mkdir(parents=True)
        build.mkdir(parents=True)

        # Create initial storygraph
        storygraph = {
            "version": "1.0",
            "project_id": "test",
            "entities": [{
                "id": "CHAR_001",
                "type": "character",
                "name": "John",
                "aliases": ["Johnny"],
                "evidence_ids": ["ev_001"]
            }],
            "edges": [],
            "evidence_index": {}
        }
        (build / "storygraph.json").write_text(json.dumps(storygraph))

        return tmp_path

    def test_parse_vault_note(self, project):
        """Test parsing vault note content."""
        reingester = VaultReingester(project)

        # Create vault note
        note = project / "vault" / "10_Characters" / "john.md"
        note.write_text(f"""---
id: CHAR_001
name: John
type: character
aliases: [Johnny, J]
---

# John

{BEGIN_MARKER}
## Aliases

- Johnny
- J

## Evidence

- [[inbox/note.md#^ev_001]]
{END_MARKER}

## Notes

User notes here.
""")

        data = reingester.parse_vault_note(note)

        assert data is not None
        assert data["frontmatter"]["id"] == "CHAR_001"
        assert data["frontmatter"]["name"] == "John"
        assert "Johnny" in data["frontmatter"]["aliases"]
        assert data["has_markers"] is True

    def test_detect_vault_changes(self, project):
        """Test detecting changed vault files."""
        reingester = VaultReingester(project)

        # Create vault note
        note = project / "vault" / "10_Characters" / "john.md"
        note.write_text(f"""---
id: CHAR_001
name: John
---

{BEGIN_MARKER}
content
{END_MARKER}
""")

        # Mark as synced
        reingester.change_detector.mark_synced(note)

        # No changes
        changes = reingester.detect_vault_changes()
        assert len(changes) == 0

        # Modify
        note.write_text(f"""---
id: CHAR_001
name: Johnny
---

{BEGIN_MARKER}
content
{END_MARKER}
""")

        changes = reingester.detect_vault_changes()
        assert len(changes) == 1

    def test_merge_entity(self, project):
        """Test merging vault data with existing entity."""
        reingester = VaultReingester(project)

        vault_data = {
            "frontmatter": {
                "id": "CHAR_001",
                "name": "Johnny",
                "aliases": ["Johnny", "J"],
                "type": "character"
            },
            "body": "",
            "protected_content": "",
            "file": "vault/10_Characters/john.md"
        }

        existing = {
            "id": "CHAR_001",
            "type": "character",
            "name": "John",
            "aliases": ["John", "Johnny"],
            "evidence_ids": ["ev_001"]
        }

        merged, conflict_ids = reingester.merge_entity(vault_data, existing)

        # Name change is ambiguous - not auto-updated
        assert merged["name"] == "John"
        # Aliases should be merged (SAFE conflict)
        # Note: depends on conflict resolution behavior
```
</action>
  <verify>python -m pytest tests/unit/test_sync.py -v --tb=short 2>&1 | head -50</verify>
  <done>Unit tests cover change detection, protected blocks, provenance, conflict resolution, and re-ingestion</done>
</task>

</tasks>

<verification>
- VaultNoteWriter imports without errors
- Protected block replacement works correctly
- Manual edits are preserved on rebuild
- Unit tests pass for sync module
</verification>

<success_criteria>
- Updated VaultNoteWriter with _write_with_protection method
- Tests in tests/unit/test_sync.py pass
- Protected block replacement tested
- Evidence links preserved across rebuilds
</success_criteria>

<output>
After completion, create `.planning/phases/03-round-trip-editing/03-04-SUMMARY.md`
</output>
