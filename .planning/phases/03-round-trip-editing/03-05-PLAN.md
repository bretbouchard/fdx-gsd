---
phase: 03-round-trip-editing
plan: 05
type: execute
wave: 5
depends_on: ["03-04"]
files_modified:
  - apps/cli/cli.py
  - tests/integration/test_round_trip.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can run 'gsd sync' to re-ingest vault changes"
    - "User can run 'gsd build canon --incremental' for faster builds"
    - "Conflicts are visible via 'gsd conflicts' command"
    - "End-to-end round-trip works: build -> edit -> sync -> rebuild"
  artifacts:
    - path: "apps/cli/cli.py"
      provides: "CLI commands for sync workflow"
      exports: ["sync", "conflicts"]
    - path: "tests/integration/test_round_trip.py"
      provides: "End-to-end round-trip tests"
  key_links:
    - from: "apps/cli/cli.py"
      to: "core/sync/reingest.py"
      via: "VaultReingester"
      pattern: "VaultReingester"
    - from: "apps/cli/cli.py"
      to: "core/canon/__init__.py"
      via: "CanonBuilder with incremental support"
      pattern: "CanonBuilder"
---

<objective>
Integrate sync functionality into CLI and create end-to-end tests for round-trip editing.

Purpose: Users need CLI commands to trigger sync operations and see conflicts. The integration tests verify the complete round-trip flow works correctly.
Output: Updated CLI with sync/conflicts commands and comprehensive integration tests.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Dependencies from Plans 01-04
@core/sync/__init__.py

# Existing CLI
@apps/cli/cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CLI sync and conflicts commands</name>
  <files>apps/cli/cli.py</files>
  <action>
Add new CLI commands to apps/cli/cli.py for round-trip editing:

1. Add a `sync` command that runs vault re-ingestion
2. Add a `conflicts` command to view/resolve conflicts
3. Add `--incremental` flag to build commands

Find the existing CLI structure (using click) and add these commands:

```python
# Add to existing imports section:
from core.sync import (
    VaultReingester,
    ReingestResult,
    ConflictResolver,
    ConflictTier,
    ChangeDetector,
)

# Add new commands after existing build commands:

@cli.command()
@click.pass_obj
def sync(ctx):
    """Re-ingest vault changes into StoryGraph.

    Detects modified vault files and syncs them back to storygraph.json.
    Conflicts are flagged in build/conflicts.json for review.

    Examples:
        gsd sync
    """
    project_path = ctx.get('project_path')
    if not project_path:
        click.echo("Error: Not in a GSD project", err=True)
        raise SystemExit(1)

    reingester = VaultReingester(project_path)
    result = reingester.run()

    click.echo(f"\n=== Vault Sync Results ===")
    click.echo(f"Files checked: {result.files_checked}")
    click.echo(f"Files changed: {result.files_changed}")
    click.echo(f"Entities updated: {result.entities_updated}")
    click.echo(f"Entities created: {result.entities_created}")

    if result.conflicts_critical > 0:
        click.echo(f"\n{click.style(str(result.conflicts_critical), fg='red')} critical conflicts (blocking)")
    if result.conflicts_ambiguous > 0:
        click.echo(f"{click.style(str(result.conflicts_ambiguous), fg='yellow')} ambiguous conflicts (review needed)")
    if result.conflicts_safe > 0:
        click.echo(f"{click.style(str(result.conflicts_safe), fg='green')} safe conflicts (auto-merged)")

    if result.errors:
        click.echo(f"\nErrors:")
        for error in result.errors:
            click.echo(f"  - {error}")

    if result.success:
        click.echo(f"\n{click.style('Sync complete', fg='green')}")
    else:
        click.echo(f"\n{click.style('Sync completed with issues', fg='yellow')}")


@cli.command()
@click.option('--resolve', metavar='ID', help='Resolve conflict by ID')
@click.option('--value', help='Value to use for resolution')
@click.option('--clear-resolved', is_flag=True, help='Remove resolved conflicts from display')
@click.pass_obj
def conflicts(ctx, resolve, value, clear_resolved):
    """View and resolve sync conflicts.

    Without options, lists all pending conflicts.

    Examples:
        gsd conflicts                    # List all conflicts
        gsd conflicts --resolve conf_001 --value "John Smith"
    """
    project_path = ctx.get('project_path')
    if not project_path:
        click.echo("Error: Not in a GSD project", err=True)
        raise SystemExit(1)

    build_path = project_path / 'build'
    conflicts_path = build_path / 'conflicts.json'

    if not conflicts_path.exists():
        click.echo("No conflicts file found. Run 'gsd sync' first.")
        return

    resolver = ConflictResolver(conflicts_path)

    if resolve:
        # Resolve a specific conflict
        if not value:
            click.echo("Error: --value is required when using --resolve", err=True)
            raise SystemExit(1)

        conflict = resolver.resolve_manual(resolve, value)
        if conflict:
            click.echo(f"Resolved conflict {resolve}")
        else:
            click.echo(f"Conflict {resolve} not found", err=True)
            raise SystemExit(1)
        return

    if clear_resolved:
        resolver.clear_resolved()
        click.echo("Cleared resolved conflicts from display")
        return

    # List conflicts
    pending = resolver.get_pending_conflicts()

    if not pending:
        click.echo("No pending conflicts.")
        return

    click.echo(f"\n=== Pending Conflicts ({len(pending)}) ===\n")

    critical = [c for c in pending if c.tier == ConflictTier.CRITICAL]
    ambiguous = [c for c in pending if c.tier == ConflictTier.AMBIGUOUS]
    safe = [c for c in pending if c.tier == ConflictTier.SAFE]

    if critical:
        click.echo(click.style("CRITICAL (blocking):", fg='red', bold=True))
        for c in critical:
            click.echo(f"  [{c.id}] {c.entity_id}.{c.field}")
            click.echo(f"      Vault: {c.vault_value}")
            click.echo(f"      Extracted: {c.extracted_value}")
            click.echo(f"      {c.message}")
            click.echo()

    if ambiguous:
        click.echo(click.style("AMBIGUOUS (review needed):", fg='yellow', bold=True))
        for c in ambiguous:
            click.echo(f"  [{c.id}] {c.entity_id}.{c.field}")
            click.echo(f"      Vault: {c.vault_value}")
            click.echo(f"      Extracted: {c.extracted_value}")
            click.echo()

    if safe:
        click.echo(click.style("SAFE (auto-merge):", fg='green', bold=True))
        for c in safe:
            click.echo(f"  [{c.id}] {c.entity_id}.{c.field} - {c.message}")
        click.echo()

    click.echo(f"Use 'gsd conflicts --resolve ID --value VALUE' to resolve")


# Update existing build_canon to support incremental:
# Find the build_canon function and add --incremental flag support
# Add after the existing build_canon command options:

# @build.command('canon')
# @click.option('--incremental', is_flag=True, help='Only process changed files')
# ...
# def build_canon(..., incremental):
#     if incremental:
#         # Use change detector to filter inbox files
#         detector = ChangeDetector(build_path / 'run_state.json')
#         changed_files = detector.get_changed_files(project_path / 'inbox')
#         if not changed_files:
#             click.echo("No changes detected. Use --no-incremental for full build.")
#             return
#         click.echo(f"Processing {len(changed_files)} changed files...")
```

The exact integration depends on the current CLI structure. Follow existing patterns for command registration.
</action>
  <verify>python -c "from apps.cli.cli import cli; print('CLI OK')" && gsd sync --help 2>/dev/null || echo "CLI sync command check"</verify>
  <done>CLI has sync, conflicts commands and incremental build support</done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests for round-trip editing</name>
  <files>tests/integration/test_round_trip.py</files>
  <action>
Create comprehensive integration tests for the full round-trip flow:

```python
"""Integration tests for round-trip editing workflow.

Tests the complete flow:
1. Build canon from inbox
2. Write vault notes
3. User edits vault notes
4. Sync vault changes back
5. Rebuild canon
6. Verify manual edits preserved
"""
import json
import tempfile
from pathlib import Path

import pytest

from core.canon import CanonBuilder, build_canon
from core.sync import (
    VaultReingester,
    ChangeDetector,
    ConflictResolver,
    ConflictTier,
    replace_protected_content,
    extract_protected_content,
    BEGIN_MARKER,
    END_MARKER,
)
from core.vault import VaultNoteWriter


@pytest.fixture
def project(tmp_path):
    """Create a complete project structure for testing."""
    # Directories
    inbox = tmp_path / "inbox"
    vault = tmp_path / "vault"
    build = tmp_path / "build"

    inbox.mkdir()
    vault.mkdir()
    build.mkdir()

    (vault / "10_Characters").mkdir()
    (vault / "20_Locations").mkdir()
    (vault / "50_Scenes").mkdir()

    # Create initial storygraph
    storygraph = {
        "version": "1.0",
        "project_id": tmp_path.name,
        "entities": [],
        "edges": [],
        "evidence_index": {}
    }
    (build / "storygraph.json").write_text(json.dumps(storygraph))

    # Create evidence index
    evidence_index = {"evidence": {}}
    (build / "evidence_index.json").write_text(json.dumps(evidence_index))

    return tmp_path


class TestRoundTripFlow:
    """Tests for complete round-trip workflow."""

    def test_build_creates_vault_notes(self, project):
        """Test that canon build creates vault notes."""
        # Create inbox file
        inbox_file = project / "inbox" / "note1.md"
        inbox_file.write_text("""^ev_001

INT. DINER - DAY

JOHN enters the diner. He looks tired.

JOHN
I need coffee.

The WAITRESS nods.
""")

        # Build canon
        config = {
            "disambiguation": {
                "auto_accept": 0.95,
                "fuzzy_threshold": 70,
                "always_ask_new": False  # Auto-create for test
            }
        }
        builder = CanonBuilder(project, config)
        result = builder.build()

        # Verify vault notes created
        chars_dir = project / "vault" / "10_Characters"
        assert len(list(chars_dir.glob("*.md"))) >= 1

    def test_manual_edit_preserved_after_rebuild(self, project):
        """Test that manual edits survive rebuild."""
        # Create initial entity in storygraph
        storygraph = {
            "version": "1.0",
            "project_id": project.name,
            "entities": [{
                "id": "CHAR_001",
                "type": "character",
                "name": "John",
                "aliases": ["Johnny"],
                "evidence_ids": ["ev_001"]
            }],
            "edges": [],
            "evidence_index": {}
        }
        (project / "build" / "storygraph.json").write_text(json.dumps(storygraph))

        # Create vault note with user content
        note_path = project / "vault" / "10_Characters" / "john.md"
        note_path.write_text(f"""---
id: CHAR_001
name: John
type: character
aliases: [Johnny]
---

# John

{BEGIN_MARKER}
## Aliases

- Johnny

## Evidence

- [[inbox/note.md#^ev_001]]
{END_MARKER}

## Notes

This is my custom note about John. He's a complex character with a dark past.

### Backstory

John grew up in Chicago before moving to LA.
""")

        # Create new inbox content (simulating rebuild)
        inbox_file = project / "inbox" / "note2.md"
        inbox_file.write_text("^ev_002\n\nJOHN also goes by J.")

        # Rebuild with new evidence
        config = {"disambiguation": {"auto_accept": 0.95, "always_ask_new": False}}
        builder = CanonBuilder(project, config)
        builder.build()

        # Verify user content preserved
        updated_note = note_path.read_text()

        # User notes section should still exist
        assert "This is my custom note about John" in updated_note
        assert "### Backstory" in updated_note
        assert "John grew up in Chicago" in updated_note

        # Protected content should have been updated
        assert BEGIN_MARKER in updated_note
        assert END_MARKER in updated_note

    def test_sync_detects_vault_changes(self, project):
        """Test that sync detects and processes vault changes."""
        # Setup: Create entity and vault note
        storygraph = {
            "version": "1.0",
            "project_id": project.name,
            "entities": [{
                "id": "CHAR_001",
                "type": "character",
                "name": "John",
                "aliases": ["Johnny"],
                "evidence_ids": []
            }],
            "edges": [],
            "evidence_index": {}
        }
        (project / "build" / "storygraph.json").write_text(json.dumps(storygraph))

        note_path = project / "vault" / "10_Characters" / "john.md"
        note_content = f"""---
id: CHAR_001
name: John
type: character
aliases: [Johnny]
---

# John

{BEGIN_MARKER}
## Aliases

- Johnny
{END_MARKER}
"""
        note_path.write_text(note_content)

        # Mark as synced
        detector = ChangeDetector(project / "build" / "run_state.json")
        detector.mark_synced(note_path)

        # User edits the vault note (adds alias)
        edited_content = f"""---
id: CHAR_001
name: John
type: character
aliases: [Johnny, J]
---

# John

{BEGIN_MARKER}
## Aliases

- Johnny
- J
{END_MARKER}
"""
        note_path.write_text(edited_content)

        # Run sync
        reingester = VaultReingester(project)
        result = reingester.run()

        # Verify change detected
        assert result.files_changed >= 1
        assert result.entities_updated >= 1

        # Verify storygraph updated
        updated_sg = json.loads((project / "build" / "storygraph.json").read_text())
        char = next(e for e in updated_sg["entities"] if e["id"] == "CHAR_001")

        # Aliases should be merged (safe conflict auto-resolve)
        assert "Johnny" in char.get("aliases", [])

    def test_conflict_flagged_for_ambiguous_change(self, project):
        """Test that ambiguous changes are flagged."""
        # Setup
        storygraph = {
            "version": "1.0",
            "project_id": project.name,
            "entities": [{
                "id": "CHAR_001",
                "type": "character",
                "name": "John",
                "aliases": [],
                "evidence_ids": []
            }],
            "edges": [],
            "evidence_index": {}
        }
        (project / "build" / "storygraph.json").write_text(json.dumps(storygraph))

        note_path = project / "vault" / "10_Characters" / "john.md"
        note_content = f"""---
id: CHAR_001
name: John
type: character
---

{BEGIN_MARKER}
content
{END_MARKER}
"""
        note_path.write_text(note_content)

        detector = ChangeDetector(project / "build" / "run_state.json")
        detector.mark_synced(note_path)

        # User changes name (ambiguous - could be different character)
        edited = note_content.replace("name: John", "name: Jonathan")
        note_path.write_text(edited)

        # Run sync
        reingester = VaultReingester(project)
        result = reingester.run()

        # Should have ambiguous conflict
        assert result.conflicts_ambiguous >= 1

        # Verify conflict persisted
        resolver = ConflictResolver(project / "build" / "conflicts.json")
        pending = resolver.get_ambiguous_conflicts()
        assert len(pending) >= 1

    def test_critical_conflict_blocks(self, project):
        """Test that critical conflicts block changes."""
        # Setup with two entities
        storygraph = {
            "version": "1.0",
            "project_id": project.name,
            "entities": [
                {
                    "id": "CHAR_001",
                    "type": "character",
                    "name": "John",
                    "aliases": [],
                    "evidence_ids": []
                },
                {
                    "id": "CHAR_002",
                    "type": "character",
                    "name": "Jane",
                    "aliases": [],
                    "evidence_ids": []
                }
            ],
            "edges": [],
            "evidence_index": {}
        }
        (project / "build" / "storygraph.json").write_text(json.dumps(storygraph))

        note_path = project / "vault" / "10_Characters" / "john.md"
        note_content = f"""---
id: CHAR_001
name: John
type: character
---

{BEGIN_MARKER}
content
{END_MARKER}
"""
        note_path.write_text(note_content)

        detector = ChangeDetector(project / "build" / "run_state.json")
        detector.mark_synced(note_path)

        # User changes ID (CRITICAL)
        edited = note_content.replace("id: CHAR_001", "id: CHAR_002")
        note_path.write_text(edited)

        # Run sync
        reingester = VaultReingester(project)
        result = reingester.run()

        # Should have critical conflict
        assert result.conflicts_critical >= 1

        # Entity ID should NOT be changed
        updated_sg = json.loads((project / "build" / "storygraph.json").read_text())
        ids = [e["id"] for e in updated_sg["entities"]]
        assert "CHAR_001" in ids  # Original preserved

    def test_provenance_tracks_sources(self, project):
        """Test that provenance tracks content sources."""
        from core.sync import ProvenanceTracker, SourceType

        # Setup
        storygraph = {
            "version": "1.0",
            "project_id": project.name,
            "entities": [{
                "id": "CHAR_001",
                "type": "character",
                "name": "John",
                "aliases": [],
                "evidence_ids": []
            }],
            "edges": [],
            "evidence_index": {}
        }
        (project / "build" / "storygraph.json").write_text(json.dumps(storygraph))

        # Track extraction provenance
        tracker = ProvenanceTracker(project / "build" / "provenance.json")
        tracker.track_extraction(
            content="John",
            entity_id="CHAR_001",
            field="name",
            source_file="inbox/note1.md",
            evidence_ids=["ev_001"]
        )

        # Verify provenance recorded
        record = tracker.get_source("CHAR_001", "name")
        assert record is not None
        assert record.source_type == SourceType.EXTRACTION
        assert record.source_file == "inbox/note1.md"

        # Simulate manual edit
        note_path = project / "vault" / "10_Characters" / "john.md"
        note_path.parent.mkdir(parents=True, exist_ok=True)
        note_path.write_text(f"""---
id: CHAR_001
name: Johnny
---

{BEGIN_MARKER}
{END_MARKER}
""")

        # Track manual edit
        tracker.track_manual_edit(
            content="Johnny",
            entity_id="CHAR_001",
            field="name",
            vault_file=str(note_path)
        )

        # Verify provenance updated
        record = tracker.get_source("CHAR_001", "name")
        assert record.source_type == SourceType.MANUAL_EDIT
        assert tracker.has_changed_since_extraction("CHAR_001", "name")


class TestIncrementalBuild:
    """Tests for incremental build functionality."""

    def test_incremental_only_processes_changed(self, project):
        """Test that incremental build only processes changed files."""
        # Create multiple inbox files
        (project / "inbox" / "note1.md").write_text("^ev_001\n\nJohn enters.")
        (project / "inbox" / "note2.md").write_text("^ev_002\n\nJane enters.")

        # Initial build
        config = {"disambiguation": {"always_ask_new": False}}
        builder = CanonBuilder(project, config)
        builder.build()

        # Mark all as synced
        detector = ChangeDetector(project / "build" / "run_state.json")
        detector.mark_all_synced(project / "inbox")

        # Modify only one file
        (project / "inbox" / "note1.md").write_text("^ev_001\n\nJohn enters. He looks tired.")

        # Incremental build should only process note1
        changed = detector.get_changed_files(project / "inbox")
        assert len(changed) == 1
        assert changed[0].name == "note1.md"
```
</action>
  <verify>python -m pytest tests/integration/test_round_trip.py -v --tb=short 2>&1 | head -60</verify>
  <done>Integration tests cover full round-trip workflow including manual edit preservation</done>
</task>

</tasks>

<verification>
- CLI sync command works
- CLI conflicts command works
- Integration tests pass
- End-to-end round-trip flow verified
</verification>

<success_criteria>
- `gsd sync` command available and working
- `gsd conflicts` command available and working
- `tests/integration/test_round_trip.py` passes
- Manual edits preserved through rebuild cycle
- Conflicts properly detected and flagged
</success_criteria>

<output>
After completion, create `.planning/phases/03-round-trip-editing/03-05-SUMMARY.md`
</output>
