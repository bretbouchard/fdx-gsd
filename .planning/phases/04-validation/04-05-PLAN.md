---
phase: 04-validation
plan: 05
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - core/validation/knowledge_validator.py
  - core/validation/__init__.py
autonomous: true

must_haves:
  truths:
    - "KNOW-01 detects characters referencing unlearned information"
    - "KNOW-02 catches secrets propagating through unshown channels"
    - "KNOW-03 flags inconsistent character motives/goals"
    - "KNOW-04 detects relationship continuity issues"
    - "Issues link to character entities and scene evidence"
  artifacts:
    - path: "core/validation/knowledge_validator.py"
      provides: "KnowledgeValidator implementing KNOW-01/02/03/04"
      min_lines: 200
  key_links:
    - from: "KnowledgeValidator.validate()"
      to: "StoryGraph.scenes"
      via: "scene character tracking"
      pattern: "scene.*characters"
    - from: "KnowledgeValidator._build_knowledge_states()"
      to: "scene dialogue/action"
      via: "information extraction"
      pattern: "dialogue|action"
---

<objective>
Implement KnowledgeValidator with KNOW-01/02/03/04 continuity rules.

Purpose: Detect knowledge state problems - characters knowing things they shouldn't, secrets spreading improperly, inconsistent motives and relationships.
Output: KnowledgeValidator class extending BaseValidator
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/04-validation/04-01-SUMMARY.md

# Reference the base validator pattern
@core/validation/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement KnowledgeValidator</name>
  <files>core/validation/knowledge_validator.py, core/validation/__init__.py</files>
  <action>
Create KnowledgeValidator class extending BaseValidator:

1. **INFORMATION_PATTERNS** class attribute - patterns for knowledge indicators:
   - r"(?:reveals?|tells?|informs?|confesses?)\s+(.+?)\s+that\s+"
   - r"(?:discovers?|learns?|finds out|realizes?)\s+(?:that\s+)?(.+?)(?:\.|,)"
   - r"(?:secret|hidden|confidential|private)\s+(.+?)"
   - r"(.+?)\s+(?:doesn'?t|don'?t|did not)\s+know"

2. **RELATIONSHIP_MARKERS** class attribute - patterns for relationship changes:
   - r"(?:befriends?|allies? with|betrays?|kills?|falls? in love with)\s+"
   - r"(?:enemy|rival|ally|friend|lover|spouse)\s+"

3. **validate() -> List[Issue]** implementation:
   - Call _load_graphs()
   - Build knowledge states: character_id -> {scene_num: set of known_facts}
   - Build relationship timeline: (char_a, char_b) -> [{scene_num, relationship_state}]
   - Run _check_unlearned_knowledge() -> KNOW-01 issues
   - Run _check_secret_propagation() -> KNOW-02 issues
   - Run _check_motive_consistency() -> KNOW-03 issues
   - Run _check_relationship_continuity() -> KNOW-04 issues
   - Return sorted issues

4. **_build_knowledge_states() -> Dict[str, Dict[int, Set[str]]]**:
   - For each scene in order:
     - Identify information revealed in scene
     - Identify characters present in scene
     - Add information to knowledge state of present characters
   - Track knowledge propagation through dialogue mentions
   - Return nested dict: character_id -> scene_num -> known_facts

5. **_extract_revealed_information(scene: Dict) -> List[Dict]**:
   - Apply INFORMATION_PATTERNS to scene content
   - Return list of: {fact: str, revealed_by: str, characters_present: List[str]}

6. **_get_characters_present(scene: Dict) -> List[str]**:
   - Get from scene.characters if available
   - Otherwise, scan scene content for character mentions
   - Return list of character_ids

7. **_check_unlearned_knowledge(knowledge_states: Dict)** - KNOW-01:
   - For each character action or dialogue:
     - Check if character references information
     - Check if character's knowledge state includes that information
     - If character acts on info they shouldn't know, create ERROR issue
   - Suggested fix: "Character {name} shouldn't know {fact} - add learning scene before scene {n}"

8. **_check_secret_propagation(knowledge_states: Dict)** - KNOW-02:
   - Identify secrets (marked with "secret" pattern or explicitly flagged)
   - Track who knows each secret and when they learned it
   - If secret spreads without shown channel, create WARNING issue
   - Suggested fix: "Show how {character} learned about {secret}"

9. **_check_motive_consistency()** - KNOW-03:
   - Extract character goals/motives from entity attributes or scene content
   - Check if actions align with stated motives
   - If character acts against established motive without explanation, create WARNING issue
   - Suggested fix: "Character {name}'s action conflicts with their goal to {goal}"

10. **_check_relationship_continuity(rel_timeline: Dict)** - KNOW-04:
    - For each character pair, track relationship state changes
    - If relationship changes without showing the change event, create WARNING issue
    - Suggested fix: "Show {char_a} and {char_b}'s relationship change from {old_state} to {new_state}"

11. **_extract_relationship_state(scene: Dict, char_a: str, char_b: str) -> Optional[str]**:
    - Apply RELATIONSHIP_MARKERS to dialogue/action between characters
    - Return detected relationship state or None

12. **Update __init__.py** to export KnowledgeValidator

Note: Knowledge validation is complex and may produce false positives. Use WARNING severity for most issues. Only use ERROR when the inconsistency is unambiguous (e.g., character references secret that was never revealed to anyone).
  </action>
  <verify>python -c "from core.validation import KnowledgeValidator, IssueCategory; from pathlib import Path; kv = KnowledgeValidator(Path('.')); print(f'Category: {IssueCategory.KNOWLEDGE}')" </verify>
  <done>KnowledgeValidator implements validate() returning List[Issue], covers KNOW-01/02/03/04 rules, extends BaseValidator</done>
</task>

</tasks>

<verification>
- Run: python -c "from core.validation import KnowledgeValidator; from pathlib import Path; kv = KnowledgeValidator(Path('.')); issues = kv.validate(); print(f'Found {len(issues)} issues')"
- Verify KNOW-01 issues have severity=ERROR (unambiguous knowledge violation)
- Verify KNOW-02 issues have severity=WARNING (possible secret channel issue)
- Verify KNOW-03 issues have severity=WARNING (motive inconsistency)
- Verify KNOW-04 issues have severity=WARNING (relationship continuity)
- Verify all issues have rule_code starting with "KNOW-"
</verification>

<success_criteria>
- KNOW-01 detects characters acting on unlearned info (ERROR)
- KNOW-02 catches improper secret propagation (WARNING)
- KNOW-03 flags motive inconsistencies (WARNING)
- KNOW-04 detects relationship continuity issues (WARNING)
- Knowledge states built from scene character presence
- Gracefully handles ambiguous knowledge states (uses WARNING)
</success_criteria>

<output>
After completion, create `.planning/phases/04-validation/04-05-SUMMARY.md`
</output>
