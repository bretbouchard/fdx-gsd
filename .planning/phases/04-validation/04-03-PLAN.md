---
phase: 04-validation
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - core/validation/props_validator.py
  - core/validation/__init__.py
autonomous: true

must_haves:
  truths:
    - "PROP-01 detects props appearing without introduction"
    - "PROP-02 catches ownership transfers not shown on screen"
    - "PROP-03 flags prop damage that doesn't persist"
    - "Issues link to prop entities and scene evidence"
  artifacts:
    - path: "core/validation/props_validator.py"
      provides: "PropsValidator implementing PROP-01/02/03"
      min_lines: 150
  key_links:
    - from: "PropsValidator.validate()"
      to: "StoryGraph.entities (props)"
      via: "prop entity iteration"
      pattern: "entity.*type.*prop"
---

<objective>
Implement PropsValidator with PROP-01/02/03 continuity rules.

Purpose: Detect prop continuity errors - unintroduced props, missing ownership transfers, damage persistence issues.
Output: PropsValidator class extending BaseValidator
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/04-validation/04-01-SUMMARY.md

# Reference the base validator pattern
@core/validation/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PropsValidator</name>
  <files>core/validation/props_validator.py, core/validation/__init__.py</files>
  <action>
Create PropsValidator class extending BaseValidator:

1. **PROP_PATTERNS** class attribute - regex patterns to detect prop mentions:
   - r"(?:holds?|holding|carries?|carrying)\s+(?:a|the)\s+(.+?)(?:\.|,|\n)"
   - r"(?:takes?|grabbed?|picks? up)\s+(?:a|the)\s+(.+?)(?:\.|,|\n)"
   - r"(?:gives?|hands?|passes?)\s+(.+?)\s+to\s+"
   - r"(?:dropped?|broke?|shattered?|destroyed?)\s+(?:the|a)\s+(.+)"

2. **validate() -> List[Issue]** implementation:
   - Call _load_graphs()
   - Build prop timeline: prop_name -> [{scene_id, scene_num, action, holder, evidence_ids}]
   - Run _check_prop_introductions() -> PROP-01 issues
   - Run _check_ownership_transfers() -> PROP-02 issues
   - Run _check_damage_persistence() -> PROP-03 issues
   - Return sorted issues

3. **_build_prop_timeline() -> Dict[str, List[Dict]]**:
   - Scan all scene content for prop mentions using PROP_PATTERNS
   - Track: prop name, action (introduced/held/transferred/damaged), holder character, scene info
   - Group by normalized prop name
   - Return timeline dict

4. **_normalize_prop_name(name: str) -> str**:
   - Lowercase, strip articles (a, an, the)
   - Normalize variations (gun/pistol/weapon -> consolidate if configured)
   - Return normalized name

5. **_check_prop_introductions(timeline: Dict)** - PROP-01:
   - For each prop, find first appearance
   - Check if action is "introduction" (explicit first mention, discovery, receiving)
   - If prop appears without introduction action, create WARNING issue
   - Suggested fix: "Add introduction beat for {prop_name} before scene {first_scene}"

6. **_check_ownership_transfers(timeline: Dict)** - PROP-02:
   - Track prop holder changes
   - If holder changes between scenes without transfer action, create ERROR issue
   - Transfer actions: gives, hands, passes, leaves behind, takes from
   - Suggested fix: "Show {character_a} giving {prop} to {character_b}"

7. **_check_damage_persistence(timeline: Dict)** - PROP-03:
   - Track prop state changes (broken, damaged, destroyed)
   - If damaged prop appears intact later without repair beat, create WARNING issue
   - Suggested fix: "Show {prop} being repaired or note replacement"

8. **_get_holder_at_scene(prop_timeline: List[Dict], scene_num: int) -> Optional[str]**:
   - Find who held the prop at the given scene
   - Return character_id or None

9. **_has_transfer_action(prop_timeline: List[Dict], from_scene: int, to_scene: int) -> bool**:
   - Check if there's an explicit transfer between scenes
   - Return True if transfer action exists

10. **Update __init__.py** to export PropsValidator

Note: Props may not be explicit entities in StoryGraph yet. The validator should work with prop mentions extracted from scene content. If StoryGraph has prop-type entities, use them; otherwise, extract from content.
  </action>
  <verify>python -c "from core.validation import PropsValidator, IssueCategory; from pathlib import Path; pv = PropsValidator(Path('.')); print(f'Category: {IssueCategory.PROPS}')" </verify>
  <done>PropsValidator implements validate() returning List[Issue], covers PROP-01/02/03 rules, extends BaseValidator</done>
</task>

</tasks>

<verification>
- Run: python -c "from core.validation import PropsValidator; from pathlib import Path; pv = PropsValidator(Path('.')); issues = pv.validate(); print(f'Found {len(issues)} issues')"
- Verify PROP-01 issues have severity=WARNING
- Verify PROP-02 issues have severity=ERROR
- Verify PROP-03 issues have severity=WARNING
- Verify all issues have rule_code starting with "PROP-"
</verification>

<success_criteria>
- PROP-01 detects unintroduced props (WARNING)
- PROP-02 catches missing ownership transfers (ERROR)
- PROP-03 flags damage persistence issues (WARNING)
- All issues link to prop mentions and scene evidence
- Handles props extracted from content (not just explicit entities)
</success_criteria>

<output>
After completion, create `.planning/phases/04-validation/04-03-SUMMARY.md`
</output>
