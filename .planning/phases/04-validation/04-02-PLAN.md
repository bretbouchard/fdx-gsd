---
phase: 04-validation
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - core/validation/wardrobe_validator.py
  - core/validation/__init__.py
autonomous: true

must_haves:
  truths:
    - "WARD-01 detects wardrobe state changes without cause beat"
    - "WARD-02 catches conflicting wardrobe in continuous timeline"
    - "WARD-03 flags missing signature items"
    - "Issues link to character entities and scene evidence"
  artifacts:
    - path: "core/validation/wardrobe_validator.py"
      provides: "WardrobeValidator implementing WARD-01/02/03"
      min_lines: 150
  key_links:
    - from: "WardrobeValidator.validate()"
      to: "StoryGraph.entities (characters)"
      via: "character entity iteration"
      pattern: "entity.*type.*character"
    - from: "WardrobeValidator.validate()"
      to: "StoryGraph.scenes"
      via: "scene content parsing"
      pattern: "scene.*content"
---

<objective>
Implement WardrobeValidator with WARD-01/02/03 continuity rules.

Purpose: Detect wardrobe inconsistencies across scenes - unexplained changes, timeline conflicts, missing signature items.
Output: WardrobeValidator class extending BaseValidator
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/04-validation/04-01-SUMMARY.md

# Reference the base validator pattern
@core/validation/base.py

# Reference extraction patterns for regex usage
@core/extraction/patterns.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement WardrobeValidator</name>
  <files>core/validation/wardrobe_validator.py, core/validation/__init__.py</files>
  <action>
Create WardrobeValidator class extending BaseValidator:

1. **WARDROBE_PATTERNS** class attribute - regex patterns to detect wardrobe mentions:
   - r"wearing\s+(.+?)(?:\.|,|\n)"
   - r"dressed\s+in\s+(.+?)(?:\.|,|\n)"
   - r"in\s+(?:a|the)\s+(\w+)\s+(?:coat|jacket|dress|suit|outfit)"
   - r"(\w+)\s+(?:cloak|robe|uniform|costume)"

2. **SIGNATURE_ITEMS** class attribute - empty dict by default, can be populated from config:
   - Maps character_id -> list of signature items that should persist

3. **validate() -> List[Issue]** implementation:
   - Call _load_graphs()
   - Build wardrobe timeline: character_id -> [{scene_id, scene_num, wardrobe_state, evidence_ids}]
   - For each character with wardrobe mentions:
     - Run _check_state_changes() -> WARD-01 issues
     - Run _check_timeline_conflicts() -> WARD-02 issues
     - Run _check_signature_items() -> WARD-03 issues
   - Return sorted issues (by severity, then scene_number)

4. **_build_wardrobe_timeline() -> Dict[str, List[Dict]]**:
   - Iterate StoryGraph.entities where type="character"
   - For each character, find scenes where they appear
   - Extract wardrobe state from scene content using WARDROBE_PATTERNS
   - Return timeline dict

5. **_extract_wardrobe_state(scene: Dict) -> Optional[str]**:
   - Get scene content (from scriptgraph paragraphs or scene notes)
   - Apply WARDROBE_PATTERNS to extract wardrobe description
   - Return first match or None

6. **_check_state_changes(timeline: Dict)** - WARD-01:
   - For each character, compare consecutive scenes
   - If wardrobe_state changes, check for cause beat (time skip markers like "LATER", "THE NEXT DAY", costume change mention)
   - If no cause beat found, create WARNING issue with suggested_fix

7. **_check_timeline_conflicts(timeline: Dict)** - WARD-02:
   - For each character, check adjacent scenes with CONTINUOUS/MOMENTS LATER markers
   - If wardrobe differs in continuous timeline, create ERROR issue

8. **_check_signature_items(timeline: Dict)** - WARD-03:
   - For characters in SIGNATURE_ITEMS, check if signature item mentioned in wardrobe
   - If signature item missing, create INFO issue

9. **_has_costume_change_cause(prev_scene_id, curr_scene_id, evidence_ids) -> bool**:
   - Check for time skip markers in scene transitions
   - Check for explicit costume change mentions
   - Return True if cause found

10. **_are_adjacent_timeline(scene_a_id, scene_b_id) -> bool**:
    - Check scene metadata for CONTINUOUS, MOMENTS LATER, SAME TIME markers
    - Return True if scenes are in continuous time

11. **Update __init__.py** to export WardrobeValidator

Focus on deterministic, rule-based detection. No ML/NER. Use re module for pattern matching.
  </action>
  <verify>python -c "from core.validation import WardrobeValidator, IssueCategory; from pathlib import Path; wv = WardrobeValidator(Path('.')); print(f'Category: {IssueCategory.WARDROBE}')" </verify>
  <done>WardrobeValidator implements validate() returning List[Issue], covers WARD-01/02/03 rules, extends BaseValidator</done>
</task>

</tasks>

<verification>
- Run: python -c "from core.validation import WardrobeValidator; from pathlib import Path; wv = WardrobeValidator(Path('.')); issues = wv.validate(); print(f'Found {len(issues)} issues')"
- Verify WARD-01 issues have severity=WARNING
- Verify WARD-02 issues have severity=ERROR
- Verify WARD-03 issues have severity=INFO
- Verify all issues have rule_code starting with "WARD-"
</verification>

<success_criteria>
- WARD-01 detects unexplained wardrobe changes (WARNING)
- WARD-02 catches timeline conflicts (ERROR)
- WARD-03 flags missing signature items (INFO)
- All issues link to character entity_ids and scene evidence_ids
- Follows BaseValidator pattern exactly
</success_criteria>

<output>
After completion, create `.planning/phases/04-validation/04-02-SUMMARY.md`
</output>
