---
phase: 01-canon-extraction
plan: 04
type: execute
wave: 3
depends_on:
  - 01-03
files_modified:
  - core/canon/__init__.py
  - apps/cli/cli.py
  - tests/integration/test_canon_pipeline.py
autonomous: false
user_setup: []

must_haves:
  truths:
    - "User can run gsd resolve to see disambiguation items"
    - "User can accept/reject/skip each item interactively"
    - "Accepted merges create aliases in storygraph"
    - "Rejected items create new entities"
    - "Resolved items are marked resolved in queue"
  artifacts:
    - path: "build/disambiguation_queue.json"
      provides: "Queue of items needing human resolution"
      contains: "items array with status field"
    - path: "apps/cli/cli.py"
      provides: "gsd resolve command"
      exports: ["cmd_resolve"]
    - path: "core/canon/__init__.py"
      provides: "Resolution application logic"
  key_links:
    - from: "apps/cli/cli.py"
      to: "build/disambiguation_queue.json"
      via: "json load"
      pattern: "json.loads.*queue"
    - from: "apps/cli/cli.py"
      to: "build/storygraph.json"
      via: "resolution application"
      pattern: "storygraph.*write"
---

<objective>
Complete the interactive disambiguation resolution workflow so users can resolve ambiguous entity matches.

Purpose: Enable human-in-the-loop resolution of entities that cannot be auto-merged due to confidence thresholds. This implements CAN-05 (Disambiguation Queue) fully.

Output: Working `gsd resolve` command that allows users to accept/reject/skip disambiguation items with proper state updates.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing code to modify
@apps/cli/cli.py (cmd_resolve, _apply_resolution, _create_entity_from_queue)
@core/canon/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance cmd_resolve with vault note updates</name>
  <files>apps/cli/cli.py</files>
  <action>
Enhance cmd_resolve() to update vault notes when resolutions are applied.

Current behavior:
- Updates storygraph.json
- Updates disambiguation_queue.json

Needed additions:
1. When resolution is "accepted" (merge/link):
   - Import VaultNoteWriter
   - Update the target entity's note in vault/
   - Add new alias to note's aliases list
   - Add new evidence link to note

2. When resolution is "rejected" (create new):
   - Create new vault note for the entity
   - Use appropriate template (character/location)

Add helper function:
```python
def _update_vault_note(project_path: Path, entity: dict):
    \"\"\"Update vault note after resolution.\"\"\"
    from core.vault import VaultNoteWriter
    writer = VaultNoteWriter(
        project_path / "vault",
        project_path / "build"
    )

    entity_type = entity.get("type")
    if entity_type == "character":
        writer.write_character(entity)
    elif entity_type == "location":
        writer.write_location(entity)
```

Call this after _apply_resolution() and _create_entity_from_queue().
  </action>
  <verify>
python -c "from apps.cli.cli import cmd_resolve, _update_vault_note; print('resolve OK')"
  </verify>
  <done>cmd_resolve updates vault notes after each resolution</done>
</task>

<task type="auto">
  <name>Task 2: Add resolution audit trail</name>
  <files>apps/cli/cli.py, core/canon/__init__.py</files>
  <action>
Add audit trail to disambiguation queue items when resolved.

In cmd_resolve, when marking item resolved:
```python
item["status"] = "resolved"
item["resolved_at"] = datetime.now().isoformat()
item["resolution"] = action  # "accepted" or "rejected"
item["resolution_user"] = os.environ.get("USER", "unknown")  # optional
```

Also add to CanonBuilder when creating queue items:
```python
"created_at": datetime.now().isoformat(),
"source_file": candidate.source_file,
"source_line": candidate.line_number,
```

This provides full traceability of:
- When the ambiguity was detected
- What the system recommended
- When/how it was resolved
- Who resolved it (if available)
  </action>
  <verify>
grep -n "resolved_at" /Users/bretbouchard/apps/fdx_gsd/apps/cli/cli.py | head -3
  </verify>
  <done>Queue items have audit trail with created_at, resolved_at, resolution</done>
</task>

<task type="checkpoint:human-verify">
  <what-built>Complete disambiguation workflow: cmd_resolve with vault note updates and audit trail</what-built>
  <how-to-verify>
1. Create a test project: `cd /tmp && python -m apps.cli.cli new-project test_resolve`
2. Add ambiguous content:
   ```
   cd test_resolve
   python -m apps.cli.cli ingest --text "ELIZABETH enters. BETH waves. LIZ looks around."
   ```
3. Build canon: `python -m apps.cli.cli build canon`
4. Resolve: `python -m apps.cli.cli resolve`
5. Test the interactive prompt:
   - Press 'a' to accept (merge)
   - Press 'r' to reject (create new)
   - Press 's' to skip
   - Press 'q' to quit
6. Check vault notes were updated:
   - `cat vault/10_Characters/elizabeth.md`
7. Check queue was updated:
   - `cat build/disambiguation_queue.json | grep resolved`
  </how-to-verify>
  <resume-signal>Type "approved" if disambiguation works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `gsd resolve` presents items interactively with context
2. Accepting merges updates storygraph + vault note
3. Rejecting creates new entity + vault note
4. Queue items marked resolved with audit trail
</verification>

<success_criteria>
- [ ] cmd_resolve updates vault notes after resolution
- [ ] _update_vault_note helper function exists
- [ ] Queue items have created_at, resolved_at, resolution fields
- [ ] Interactive prompt works (a/r/s/q)
- [ ] Human verification checkpoint passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-canon-extraction/01-04-SUMMARY.md`
</output>
