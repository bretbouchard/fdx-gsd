---
phase: 01-canon-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - core/vault/__init__.py
  - core/vault/note_writer.py
  - core/vault/templates.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can run gsd build canon and see character notes in vault/10_Characters/"
    - "User can run gsd build canon and see location notes in vault/20_Locations/"
    - "User can run gsd build canon and see scene notes in vault/50_Scenes/"
    - "Each vault note has a link back to source evidence"
  artifacts:
    - path: "core/vault/note_writer.py"
      provides: "VaultNoteWriter class for generating Obsidian notes"
      exports: ["VaultNoteWriter", "write_entity_note"]
    - path: "core/vault/templates.py"
      provides: "Note templates for character, location, scene"
      exports: ["CHARACTER_TEMPLATE", "LOCATION_TEMPLATE", "SCENE_TEMPLATE"]
    - path: "vault/10_Characters/"
      provides: "Character notes storage"
    - path: "vault/20_Locations/"
      provides: "Location notes storage"
    - path: "vault/50_Scenes/"
      provides: "Scene notes storage"
  key_links:
    - from: "core/canon/__init__.py"
      to: "core/vault/note_writer.py"
      via: "import and call write_entity_note"
      pattern: "from.*vault.*import"
    - from: "core/vault/note_writer.py"
      to: "vault/10_Characters/*.md"
      via: "file write"
      pattern: "Path.*write_text"
---

<objective>
Create the vault note writer that generates Obsidian-compatible markdown notes for extracted entities.

Purpose: Transform extracted entities (characters, locations, scenes) into human-readable, Obsidian-compatible notes in the vault with evidence links back to source material.

Output: VaultNoteWriter class with templates that produces structured markdown notes in vault/ directories.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing code to build on
@core/canon/__init__.py
@core/extraction/base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create note templates module</name>
  <files>core/vault/templates.py</files>
  <action>
Create the note templates module at `core/vault/templates.py`.

Define three Jinja2-like template strings (but use Python f-strings or string.Template - no external dependency needed):

CHARACTER_TEMPLATE - For character notes:
- YAML frontmatter with: id, name, type, aliases, created_at
- Body with: name heading, aliases list, first_appearance, evidence_links section
- Use Obsidian link format: [[inbox/filename#^block_ref]]

LOCATION_TEMPLATE - For location notes:
- YAML frontmatter with: id, name, type, int_ext, time_of_day (if known), created_at
- Body with: name heading, int_ext indicator, description placeholder, evidence_links

SCENE_TEMPLATE - For scene notes:
- YAML frontmatter with: id, scene_number, location, int_ext, time_of_day, created_at
- Body with: slugline heading, location link, characters placeholder, evidence_links

Each template should:
1. Accept a dict with entity data (id, name, type, aliases, evidence_ids, etc.)
2. Format evidence_ids as Obsidian wikilinks
3. Include a protected block marker: <!-- CONFUCIUS:BEGIN AUTO --> ... <!-- CONFUCIUS:END AUTO -->
4. Be deterministic (same input = same output) for hash-based change detection
  </action>
  <verify>
python -c "from core.vault.templates import CHARACTER_TEMPLATE, LOCATION_TEMPLATE, SCENE_TEMPLATE; print('Templates loaded OK')"
  </verify>
  <done>Three template constants exist and are importable, each with frontmatter and Obsidian-compatible structure</done>
</task>

<task type="auto">
  <name>Task 2: Create vault note writer</name>
  <files>core/vault/note_writer.py, core/vault/__init__.py</files>
  <action>
Create `core/vault/note_writer.py` with VaultNoteWriter class.

The class should:
1. `__init__(self, vault_path: Path)` - Store vault path, create subdirs if needed
2. `write_character(self, entity: dict) -> Path` - Write to vault/10_Characters/{slug}.md
3. `write_location(self, entity: dict) -> Path` - Write to vault/20_Locations/{slug}.md
4. `write_scene(self, entity: dict) -> Path` - Write to vault/50_Scenes/SCN_XXX.md
5. `format_evidence_links(self, evidence_ids: list) -> str` - Convert evidence IDs to [[inbox/...#^ev_xxxx]] format

For slug generation:
- Characters: Use normalized name (e.g., "John Smith" -> "john-smith.md")
- Locations: Use normalized name (e.g., "Coffee Shop" -> "coffee-shop.md")
- Scenes: Use SCN_XXX format from entity id

Evidence link format:
- evidence_ids are block refs like "ev_a1b2"
- Need to look up source file from evidence_index.json to build full link
- Format: [[inbox/2026-02-19_001.md#^ev_a1b2]]

Update `core/vault/__init__.py` to export:
- VaultNoteWriter
- write_entity_note (convenience function)
- CHARACTER_TEMPLATE, LOCATION_TEMPLATE, SCENE_TEMPLATE
  </action>
  <verify>
python -c "from core.vault import VaultNoteWriter; print('VaultNoteWriter loaded OK')"
  </verify>
  <done>VaultNoteWriter class exists and can be imported, with methods to write character, location, and scene notes</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for vault writer</name>
  <files>tests/unit/test_vault_writer.py</files>
  <action>
Create `tests/unit/test_vault_writer.py` with tests for:

1. `test_character_template_rendering` - Verify template produces valid markdown with frontmatter
2. `test_location_template_rendering` - Verify location template with int_ext metadata
3. `test_scene_template_rendering` - Verify scene template with scene number
4. `test_evidence_link_formatting` - Verify evidence IDs become Obsidian wikilinks
5. `test_slug_generation` - Verify names are slugified correctly for filenames
6. `test_deterministic_output` - Same entity input produces identical file content
7. `test_write_character_creates_file` - Integration test that file is created in correct dir
8. `test_protected_block_markers` - Verify <!-- CONFUCIUS:BEGIN/END AUTO --> markers present

Use tmp_path fixture for file operations.
  </action>
  <verify>
python -m pytest tests/unit/test_vault_writer.py -v --tb=short
  </verify>
  <done>All 8 tests pass, vault writer tested in isolation</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `python -m pytest tests/unit/test_vault_writer.py -v` passes
2. VaultNoteWriter can be imported from core.vault
3. Templates produce valid Obsidian-compatible markdown
</verification>

<success_criteria>
- [ ] core/vault/templates.py exists with CHARACTER_TEMPLATE, LOCATION_TEMPLATE, SCENE_TEMPLATE
- [ ] core/vault/note_writer.py exists with VaultNoteWriter class
- [ ] core/vault/__init__.py exports VaultNoteWriter and templates
- [ ] 8 unit tests pass in tests/unit/test_vault_writer.py
- [ ] Evidence links formatted as [[inbox/file#^block]]
- [ ] Protected block markers present in templates
</success_criteria>

<output>
After completion, create `.planning/phases/01-canon-extraction/01-01-SUMMARY.md`
</output>
